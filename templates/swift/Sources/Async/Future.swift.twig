//
// Created by Jake on 23/07/21.
//

import Foundation

enum FutureState {
    case pending
    case fulfilled
    case rejected
}

///
/// Represents a task that can take place in the future and eventually receive a value.
///
open class Future<Value> {

    internal var result: Result<Value, Error>? {
        didSet {
            result.map(report)
            switch result {
            case .failure: state = .rejected
            case .success: state = .fulfilled
            case .none: state = .pending
            }
        }
    }

    private var callbacks = [(Result<Value, Error>) -> Void]()

    private var state: FutureState = .pending

    var isPending: Bool {
        state == .pending
    }
    var isFulfilled: Bool {
        state == .fulfilled
    }
    var isRejected: Bool {
        state == .rejected
    }

    ///
    /// Add a callback that executes when this future completes.
    ///
    /// - Parameter callback: The callback to run when this future completes.
    ///
    public func whenComplete(_ callback: @escaping (Result<Value, Error>) -> Void) {
        if let result = result {
            callback(result)
        }
        callbacks.append(callback)
    }

    private func report(result: Result<Value, Error>) {
        callbacks.forEach {
            $0(result)
        }
        callbacks = []
    }
}
