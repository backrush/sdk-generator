//
// Created by Jake on 23/07/21.
//

import Foundation

///
/// Represents a task that takes place asynchronously and is
/// guaranteed to either resolve with a result or reject with an error.
///
open class Promise<Value>: Future<Value> {

    public init(result: Result<Value, Error>? = nil) {
        super.init()
        self.result = result
    }

    ///
    /// Create a promise immediately rejecting with the given error.
    ///
    /// - Parameter error: The error to reject this promise with.
    ///
    public convenience init(error: Error) {
        self.init(result: .failure(error))
    }

    ///
    /// Create a promise immediately resolving with the given value.
    ///
    /// - Parameter value: The value to resolve this promise with.
    ///
    public convenience init(value: Value) {
        self.init(result: .success(value))
    }

    ///
    /// Create a promise that either resolves when the given work is completed,
    /// or rejects with an error if an exception occurs.
    ///
    /// - Parameter work: The function to execute
    ///
    public init(_ work: @escaping (
        _ resolve: (_ value: Value) -> Void,
        _ reject: (_ error: Error) -> Void
    ) throws -> Void) {
        super.init()

        DispatchQueue.futures.async {
            do {
                try work({ value in
                    self.resolve(with: value)
                }, { error in
                    self.reject(with: error)
                })
            } catch let error {
                self.reject(with: error)
            }
        }
    }

    public init(_ work: @escaping () throws -> Value) {
        super.init()

        DispatchQueue.futures.async {
            do {
                let result = try work()

                switch result {
                case let error as NSError:
                    self.reject(with: error)
                default:
                    self.resolve(with: result)
                }
            } catch let error {
                self.reject(with: error)
            }
        }
    }

    public func resolve(with value: Value) {
        result = .success(value)
    }

    public func reject(with error: Error) {
        result = .failure(error)
    }
}

extension Promise: CustomStringConvertible {
    public var description: String {
        var description = "nil"
        if isFulfilled, let result = result {
            let value = try! result.get()
            description = String(describing: value)

            return "Fulfilled: \(description)"
        }
        if isRejected, let result = result {
            switch result {
            case .failure(let error): description = String(describing: error)
            case .success(_): break
            }
            return "Rejected: \(description)"
        }
        return "Pending: \(Value.self)"
    }
}
