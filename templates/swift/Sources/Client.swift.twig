//
// Client.swift
//
// Created by Armino <devel@boioiong.com>
// GitHub: https://github.com/armino-dev/sdk-generator
//

import Foundation
import AsyncHTTPClient

open class Client {

    // MARK: Properties

    open var selfSigned = false

    open var endpoint = "{{spec.endpoint}}"

    open var headers: [String: String] = [
      "content-type": "",
      "x-sdk-version": "{{spec.title | caseDash}}:{{ language.name | caseLower }}:{{ sdk.version }}"{% if spec.global.defaultHeaders | length > 0 %},{% endif %}

{% for key,header in spec.global.defaultHeaders %}
      "{{key}}": "{{header}}"{% if not loop.last %},{% endif %}
{% endfor %}
    
    ]

    open var config: [String: String] = [:]

    open var http: HTTPClient

    // MARK: Methods

    // Default constructor
    public init() {
        let timeout = HTTPClient.Configuration.Timeout(
            connect: .seconds(30),
            read: .seconds(30))

        let redirects = HTTPClient.Configuration.RedirectConfiguration
            .follow(max: 5, allowCycles: false)

        http = HTTPClient(
            eventLoopGroupProvider: .createNew,
            configuration: HTTPClient.Configuration(
                redirectConfiguration: redirects,
                timeout: timeout,
                decompression: .enabled(limit: .none)
            )
        )
    }

    deinit {
        do {
            try http.syncShutdown()
        } catch {
            print(error)
        }
    }

{% for header in spec.global.headers %}
    ///
    /// Set {{header.key | caseUcfirst}}
    ///
{% if header.description %}
    /// {{header.description}}
    ///
{% endif %}
    /// @param String value
    ///
    /// @return Client
    ///
    open func set{{ header.key | caseUcfirst }}(_ value: String) -> Client {
        config["{{ header.key | caseLower }}"] = value
        _ = addHeader(key: "{{header.name}}", value: value)
        return self
    }

{% endfor %}

    ///
    /// Set self signed
    ///
    /// @param Bool status
    ///
    /// @return Client
    ///
    open func setSelfSigned(_ status: Bool = true) -> Client {
        self.selfSigned = status
        return self
    }

    ///
    /// Set endpoint
    ///
    /// @param String endpoint
    ///
    /// @return Client
    ///
    open func setEndpoint(_ endpoint: String) -> Client {
        self.endpoint = endpoint
        return self
    }

    ///
    /// Add header
    ///
    /// @param String key
    /// @param String value
    ///
    /// @return Client
    ///
    open func addHeader(key: String, value: String) -> Client {
        self.headers[key] = value
        return self
    }

   ///
   /// Builds a query string from parameters
   ///
   /// @param Dictionary<String, Any?> params
   /// @param String prefix
   ///
   /// @return String
   ///
   open func parametersToQueryString(params: [String: Any?]) -> String {
       var output: String = ""

       func appendWhenNotLast(_ index: Int, ofTotal count: Int, outerIndex: Int? = nil, outerCount: Int? = nil) {
           if (index != count - 1 || (outerIndex != nil
               && outerCount != nil
               && index == count - 1
               && outerIndex! != outerCount! - 1)) {
               output += "&"
           }
       }

       for (parameterIndex, element) in params.enumerated() {
           switch element.value {
           case nil:
               break
           case is Array<Any?>:
               let list = element.value as! Array<Any?>
               for (nestedIndex, item) in list.enumerated() {
                   output += "\(element.key)[]=\(item!)"
                   appendWhenNotLast(nestedIndex, ofTotal: list.count, outerIndex: parameterIndex, outerCount: params.count)
               }
               appendWhenNotLast(parameterIndex, ofTotal: params.count)
           default:
               output += "\(element.key)=\(element.value!)"
               appendWhenNotLast(parameterIndex, ofTotal: params.count)
           }
       }

       return output.addingPercentEncoding(
           withAllowedCharacters: .urlHostAllowed
       ) ?? ""
   }

    ///
    /// Make an API call
    ///
    /// @param String method
    /// @param String path
    /// @param Dictionary<String, Any?> params
    /// @param Dictionary<String, String> headers
    /// @return Response
    /// @throws Exception
    ///
    func call(method: String, path: String = "", headers: [String: String] = [:], params: [String: Any?] = [:], completion: ((Result<HTTPClient.Response, {{ spec.title | caseUcfirst}}Error>) -> Void)? = nil) {
        self.headers.merge(headers) { (_, new) in
            new
        }

        let queryParameters = method == "GET" && !params.isEmpty
            ? "?" + parametersToQueryString(params: params)
            : ""

        let targetURL = URL(string: endpoint + path + queryParameters)!

        var request: HTTPClient.Request
        do {
            request = try HTTPClient.Request(
                url: targetURL,
                method: .RAW(value: method)
            )
        } catch {
            completion?(Result.failure({{ spec.title | caseUcfirst }}Error(message: error.localizedDescription)))
            return
        }

        for (key, value) in self.headers {
            request.headers.add(name: key, value: value)
        }

        let name = UserDefaults.standard.string(forKey: "cookie-name-.\(targetURL.host ?? "")")
        let value = UserDefaults.standard.string(forKey: "cookie-value-.\(targetURL.host ?? "")")

        if  name != nil && value != nil {
            request.headers.add(name: "Set-Cookie", value: "\(name!)=\(value!)")
        }

        if "GET" != method {
            var json: Data
            do {
                json = try JSONSerialization.data(
                    withJSONObject: params,
                    options: []
                )
            } catch {
                completion?(Result.failure({{ spec.title | caseUcfirst }}Error(message: error.localizedDescription)))
                return
            }

            request.body = .data(json)
        }

        http.execute(request: request).whenComplete { result in
            if let completion = completion {
                completion(result.mapError { {{ spec.title | caseUcfirst }}Error(message: $0.localizedDescription) })
            }
        }
    }
}

extension Client {

    public enum HTTPStatus: Int {
      case unknown = -1
      case ok = 200
      case created = 201
      case accepted = 202
      case movedPermanently = 301
      case found = 302
      case badRequest = 400
      case notAuthorized = 401
      case paymentRequired = 402
      case forbidden = 403
      case notFound = 404
      case methodNotAllowed = 405
      case notAcceptable = 406
      case internalServerError = 500
      case notImplemented = 501
    }
}
