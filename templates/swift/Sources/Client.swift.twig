//
// Client.swift
//
// Created by Armino <devel@boioiong.com>
// GitHub: https://github.com/armino-dev/sdk-generator
//

import Foundation
import AsyncHTTPClient

open class Client {

    // MARK: Properties

    open var selfSigned = false

    open var endpoint = "{{spec.endpoint}}"

    open var headers: [String: String] = [
      "content-type": "",
      "x-sdk-version": "{{spec.title | caseDash}}:{{ language.name | caseLower }}:{{ sdk.version }}"{% if spec.global.defaultHeaders | length > 0 %},{% endif %}

{% for key,header in spec.global.defaultHeaders %}
      "{{key}}": "{{header}}"{% if not loop.last %},{% endif %}
{% endfor %}
    
    ]

    open var config: [String: String] = [:]

    open var http: HTTPClient

    // MARK: Methods

    // Default constructor
    public init() {
        let timeout = HTTPClient.Configuration.Timeout(
            connect: .seconds(30),
            read: .seconds(30))

        let redirects = HTTPClient.Configuration.RedirectConfiguration
            .follow(max: 5, allowCycles: false)

        http = HTTPClient(
            eventLoopGroupProvider: .createNew,
            configuration: HTTPClient.Configuration(
            redirectConfiguration: redirects,
            timeout: timeout,
            decompression: .enabled(limit: .none)))
    }

    deinit {
        do {
            try http.syncShutdown()
        } catch {
            print(error)
        }
    }

{% for header in spec.global.headers %}
    ///
    /// Set {{header.key | caseUcfirst}}
    ///
{% if header.description %}
    /// {{header.description}}
    ///
{% endif %}
    /// @param String value
    ///
    /// @return Client
    ///
    open func set{{header.key | caseUcfirst}}(_ value: String) -> Client {
        config["{{ header.key | caseLower }}"] = value
        _ = addHeader(key: "{{header.name}}", value: value)
        return self
    }

{% endfor %}

    ///
    /// Set self signed
    ///
    /// @param Bool status
    ///
    /// @return Client
    ///
    open func setSelfSigned(_ status: Bool = true) -> Client {
        self.selfSigned = status
        return self
    }

    ///
    /// Set endpoint
    ///
    /// @param String endpoint
    ///
    /// @return Client
    ///
    open func setEndpoint(_ endpoint: String) -> Client {
        self.endpoint = endpoint
        return self
    }

    ///
    /// Add header
    ///
    /// @param String key
    /// @param String value
    ///
    /// @return Client
    ///
    open func addHeader(key: String, value: String) -> Client {
        self.headers[key.lowercased()] = value
        return self
    }

   ///
   /// Builds a query string from parameters
   ///
   /// @param Dictionary<String, Any?> params
   /// @param String prefix
   ///
   /// @return String
   ///
   open func parametersToQueryString(params: [String: Any?]) -> String {
       var output: String = ""

       func appendWhenNotLast(_ index: Int, ofTotal count: Int, outerIndex: Int? = nil, outerCount: Int? = nil) {
           if (index != count - 1 || (outerIndex != nil
               && outerCount != nil
               && index == count - 1
               && outerIndex! != outerCount! - 1)) {
               output += "&"
           }
       }

       for (parameterIndex, element) in params.enumerated() {
           switch element.value {
           case nil:
               break
           case is Array<Any?>:
               let list = element.value as! Array<Any?>
               for (nestedIndex, item) in list.enumerated() {
                   output += "\(element.key)[]=\(item!)"
                   appendWhenNotLast(nestedIndex, ofTotal: list.count, outerIndex: parameterIndex, outerCount: params.count)
               }
               appendWhenNotLast(parameterIndex, ofTotal: params.count)
           default:
               output += "\(element.key)=\(element.value!)"
               appendWhenNotLast(parameterIndex, ofTotal: params.count)
           }
       }

       return output.addingPercentEncoding(
           withAllowedCharacters: .urlHostAllowed
       ) ?? ""
   }

   private func buildHeaders(from baseHeaders: [String: String], andCookies cookies: [HTTPCookie]) -> [String: String] {
       func cookieHeader(from cookies: [HTTPCookie]) -> String {
           var cookieString = ""
           for (index, cookie) in cookies.enumerated() {
               if index > 0 {
                   cookieString.append("; ")
               }
               cookieString = cookieString
                   .appending("\(cookie.name)")
                   .appending("=")
                   .appending("\(cookie.value)")

           }
           return cookieString
       }
       var headers = [String: String]()
       for (key, value) in self.headers {
           headers[key] = value
       }
       let cookieString = cookieHeader(from: cookies)
       if !cookieString.isEmpty {
           headers["Cookie"] = cookieString
       }
       return headers
   }

   ///
   /// Make an API call
   ///
   /// @param String method
   /// @param String path
   /// @param Dictionary<String, Any?> params
   /// @param Dictionary<String, String> headers
   /// @return Response
   /// @throws Exception
   ///
   func call(method: String, path: String = "", headers: [String: String] = [:], params: [String: Any?] = [:]) throws -> HTTPClient.Response {
        self.headers.merge(headers) { (_, new) in new }

       let queryParameters = method == "GET" && !params.isEmpty
           ? "?" + parametersToQueryString(params: params)
           : ""

       let targetURL = URL(string: endpoint + path + queryParameters)!

       var request = try HTTPClient.Request(
           url: targetURL,
           method: .RAW(value: method)
       )

       let requestCookies = HTTPCookieStorage
           .sharedCookieStorage(forGroupContainerIdentifier: "testspec.title")
           .cookies(for: targetURL) ?? []

       for (key, value) in buildHeaders(from: self.headers, andCookies: requestCookies) {
           request.headers.add(name: key, value: value)
       }

       switch (self.headers["content-type"]) {
       case "multipart/form-data":
           // TODO: Form data
           break
       default:
           if "GET" == method {
               break
           }
           let json = try JSONSerialization.data(
               withJSONObject: params,
               options: [])

           request.body = .data(json)
       }

       let response = try http.execute(request: request).wait()

       let responseHeaders = [String: String](uniqueKeysWithValues: response.headers.map {
           ($0.name, $0.value)
       })

       let responseCookies = HTTPCookie.cookies(
           withResponseHeaderFields: responseHeaders,
           for: targetURL
       )

       HTTPCookieStorage
           .sharedCookieStorage(forGroupContainerIdentifier: "testspec.title")
           .setCookies(responseCookies, for: targetURL, mainDocumentURL: nil)

       return response
   }
}

extension Client {

    public enum HTTPStatus: Int {
      case unknown = -1
      case ok = 200
      case created = 201
      case accepted = 202
      case movedPermanently = 301
      case found = 302
      case badRequest = 400
      case notAuthorized = 401
      case paymentRequired = 402
      case forbidden = 403
      case notFound = 404
      case methodNotAllowed = 405
      case notAcceptable = 406
      case internalServerError = 500
      case notImplemented = 501
    }
}
