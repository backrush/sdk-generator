//
// Client.swift
//
// Created by Armino <devel@boioiong.com>
// GitHub: https://github.com/armino-dev/sdk-generator
//

import NIO
import NIOSSL
import Foundation
import AsyncHTTPClient

let DASHDASH = "--"
let CLRF = "\r\n"

open class Client {

    // MARK: Properties

    open var endPoint = "{{spec.endpoint}}"

    open var endPointRealtime: String? = nil

    open var headers: [String: String] = [
      "content-type": "",
      "x-sdk-version": "{{spec.title | caseDash}}:{{ language.name | caseLower }}:{{ sdk.version }}"{% if spec.global.defaultHeaders | length > 0 %},{% endif %}

{% for key,header in spec.global.defaultHeaders %}
      "{{key}}": "{{header}}"{% if not loop.last %},{% endif %}
{% endfor %}
    
    ]

    open var config: [String: String] = [:]

    open var http: HTTPClient

    private static let boundaryChars =
        "abcdefghijklmnopqrstuvwxyz1234567890"

    private static var eventLoopGroupProvider =
        HTTPClient.EventLoopGroupProvider.createNew

    // MARK: Methods

    public init() {
        http = Client.createHTTP()
    }

    private static func createHTTP(
        selfSigned: Bool = false,
        maxRedirects: Int = 5,
        alloweRedirectCycles: Bool = false,
        connectTimeout: TimeAmount = .seconds(30),
        readTimeout: TimeAmount = .seconds(30)
    ) -> HTTPClient {
        let timeout = HTTPClient.Configuration.Timeout(
            connect: connectTimeout,
            read: readTimeout
        )
        let redirect = HTTPClient.Configuration.RedirectConfiguration.follow(
            max: 5,
            allowCycles: false
        )
        var tls = TLSConfiguration
            .makeClientConfiguration()

        if selfSigned {
            tls.certificateVerification = .none
        }

        return HTTPClient(
            eventLoopGroupProvider: eventLoopGroupProvider,
            configuration: HTTPClient.Configuration(
                tlsConfiguration: tls,
                redirectConfiguration: redirect,
                timeout: timeout,
                decompression: .enabled(limit: .none)
            )
        )

    }

    deinit {
        do {
            try http.syncShutdown()
        } catch {
            print(error)
        }
    }

{% for header in spec.global.headers %}
    ///
    /// Set {{header.key | caseUcfirst}}
    ///
{% if header.description %}
    /// {{header.description}}
    ///
{% endif %}
    /// @param String value
    ///
    /// @return Client
    ///
    open func set{{ header.key | caseUcfirst }}(_ value: String) -> Client {
        config["{{ header.key | caseLower }}"] = value
        _ = addHeader(key: "{{header.name}}", value: value)
        return self
    }

{% endfor %}

    ///
    /// Set self signed
    ///
    /// @param Bool status
    ///
    /// @return Client
    ///
    open func setSelfSigned(_ status: Bool = false) -> Client {
        try! http.syncShutdown()
        http = Client.createHTTP(selfSigned: status)
        return self
    }

    ///
    /// Set endpoint
    ///
    /// @param String endPoint
    ///
    /// @return Client
    ///
    open func setEndpoint(_ endPoint: String) -> Client {
        self.endPoint = endPoint

        if (self.endPointRealtime == nil && endPoint.starts(with: "http")) {
            self.endPointRealtime = endPoint
                .replacingOccurrences(of: "http://", with: "ws://")
                .replacingOccurrences(of: "https://", with: "wss://")
        }

        return self
    }

    ///
    /// Set realtime endpoint.
    ///
    /// @param String endPoint
    ///
    /// @return Client
    ///
    func setEndpointRealtime(endPoint: String) -> Client {
        self.endPointRealtime = endPoint

        return self
    }

    ///
    /// Add header
    ///
    /// @param String key
    /// @param String value
    ///
    /// @return Client
    ///
    open func addHeader(key: String, value: String) -> Client {
        self.headers[key] = value
        return self
    }

   ///
   /// Builds a query string from parameters
   ///
   /// @param Dictionary<String, Any?> params
   /// @param String prefix
   ///
   /// @return String
   ///
   open func parametersToQueryString(params: [String: Any?]) -> String {
       var output: String = ""

       func appendWhenNotLast(_ index: Int, ofTotal count: Int, outerIndex: Int? = nil, outerCount: Int? = nil) {
           if (index != count - 1 || (outerIndex != nil
               && outerCount != nil
               && index == count - 1
               && outerIndex! != outerCount! - 1)) {
               output += "&"
           }
       }

       for (parameterIndex, element) in params.enumerated() {
           switch element.value {
           case nil:
               break
           case is Array<Any?>:
               let list = element.value as! Array<Any?>
               for (nestedIndex, item) in list.enumerated() {
                   output += "\(element.key)[]=\(item!)"
                   appendWhenNotLast(nestedIndex, ofTotal: list.count, outerIndex: parameterIndex, outerCount: params.count)
               }
               appendWhenNotLast(parameterIndex, ofTotal: params.count)
           default:
               output += "\(element.key)=\(element.value!)"
               appendWhenNotLast(parameterIndex, ofTotal: params.count)
           }
       }

       return output.addingPercentEncoding(
           withAllowedCharacters: .urlHostAllowed
       ) ?? ""
   }

    ///
    /// Make an API call
    ///
    /// @param String method
    /// @param String path
    /// @param Dictionary<String, Any?> params
    /// @param Dictionary<String, String> headers
    /// @return Response
    /// @throws Exception
    ///
    func call(method: String, path: String = "", headers: [String: String] = [:], params: [String: Any?] = [:], sink: ((ByteBuffer) -> Void)? = nil,  completion: ((Result<HTTPClient.Response, {{ spec.title | caseUcfirst}}Error>) -> Void)? = nil) {
        self.headers.merge(headers) { (_, new) in
            new
        }

        let queryParameters = method == "GET" && !params.isEmpty
            ? "?" + parametersToQueryString(params: params)
            : ""

        let targetURL = URL(string: endPoint + path + queryParameters)!

        var request: HTTPClient.Request
        do {
            request = try HTTPClient.Request(
                url: targetURL,
                method: .RAW(value: method)
            )
        } catch {
            completion?(Result.failure({{ spec.title | caseUcfirst }}Error(message: error.localizedDescription)))
            return
        }

        for (key, value) in self.headers {
            request.headers.add(name: key, value: value)
        }

        let name = UserDefaults.standard.string(forKey: "cookie-name-.\(targetURL.host ?? "")")
        let value = UserDefaults.standard.string(forKey: "cookie-value-.\(targetURL.host ?? "")")

        if  name != nil && value != nil {
            request.headers.add(name: "Set-Cookie", value: "\(name!)=\(value!)")
        }

        if "GET" == method {
            execute(request, completion: completion)
            return
        }

        do {
            if self.headers["content-type"] == "multipart/form-data" {
                buildMultipart(&request, with: params)
            } else {
                try buildJSON(&request, with: params)
            }
        } catch {
            completion?(Result.failure(AppwriteError(message: error.localizedDescription)))
            return
        }

        execute(request, withSink: sink, completion: completion)
    }

    fileprivate func execute(
        _ request: HTTPClient.Request,
        withSink bufferSink: ((ByteBuffer) -> Void)? = nil,
        completion: ((Result<HTTPClient.Response, {{ spec.title | caseUcfirst}}Error>) -> Void)? = nil
    ) {
        if bufferSink == nil {
            http.execute(
                request: request,
                delegate: ResponseAccumulator(request: request)
            ).futureResult.whenComplete { result in
                if let completion = completion {
                    completion(result.mapError { AppwriteError(message: $0.localizedDescription) })
                }
            }
            return
        }

        http.execute(
            request: request,
            delegate: StreamingDelegate(request: request, sink: bufferSink)
        ).futureResult.whenComplete { result in
            if let completion = completion {
                completion(result.mapError { AppwriteError(message: $0.localizedDescription) })
            }
        }
    }

    fileprivate func randomBoundary() -> String {
        var string = ""
        for _ in 0..<16 {
            string.append(Client.boundaryChars.randomElement()!)
        }
        return string
    }

    fileprivate func buildJSON(
        _ request: inout HTTPClient.Request,
        with params: [String: Any?] = [:]
    ) throws {
        let json = try JSONSerialization.data(withJSONObject: params, options: [])

        request.body = .data(json)
    }

    fileprivate func buildMultipart(
        _ request: inout HTTPClient.Request,
        with params: [String: Any?] = [:]
    ) {
        let boundary = randomBoundary()

        var body = ByteBuffer()

        func addPart(name: String, value: Any, filename: String? = nil) {
            body.writeString(DASHDASH)
            body.writeString(boundary)
            body.writeString(CLRF)
            body.writeString("content-disposition: form-data; name=\"\(name)\"")

            if filename != nil {
                var bodyBuffer = value as! ByteBuffer
                body.writeString("; filename=\"\(filename!)\"")
                body.writeString(CLRF)
                body.writeBuffer(&bodyBuffer)
            } else {
                body.writeString(CLRF)
                body.writeString(value as! String)
            }

            body.writeString(CLRF)
        }

        for (key, value) in params {
            switch key {
            case "file":
                addPart(name: key, value: value!, filename: boundary)
            default:
                guard let value = value as? String else  {
                    if let list = value as? [Any] {
                        for val in list {
                            addPart(name: "\(key)[]", value: val as! String)
                        }
                    }
                    break
                }
                addPart(name: key, value: value as String)
            }
        }
        body.writeString(DASHDASH)
        body.writeString(boundary)
        body.writeString(DASHDASH)
        body.writeString(CLRF)

        let bufferSize = 1024
        let size = body.readableBytes

        request.headers.remove(name: "content-type")
        request.headers.add(name: "content-type", value: "multipart/form-data;boundary=\(DASHDASH + boundary)")
        request.headers.add(name: "content-length", value: size.description)
        request.body = .byteBuffer(body)
//        request.body = .stream(length: body.readableBytes) { stream in
//
//            let buffer = size > bufferSize ?
//                body.readSlice(length: bufferSize)! :
//                body
//
//            return stream.write(.byteBuffer(buffer))
//        }
    }
}

extension Client {

    public enum HTTPStatus: Int {
      case unknown = -1
      case ok = 200
      case created = 201
      case accepted = 202
      case movedPermanently = 301
      case found = 302
      case badRequest = 400
      case notAuthorized = 401
      case paymentRequired = 402
      case forbidden = 403
      case notFound = 404
      case methodNotAllowed = 405
      case notAcceptable = 406
      case internalServerError = 500
      case notImplemented = 501
    }
}
