import Foundation
import NIO

open class Payload {

    enum Error: Swift.Error {
        case invalidType(String)
    }

    public var path: String? = nil
    public var filename: String? = nil
    public var mimeType: String? = nil
    public var data: Any? = nil

    internal init() {}

    public static func fromPath(_ path: String) -> Payload {
        let instance = Payload()
        instance.path = path
        instance.filename = URL(fileURLWithPath: path, isDirectory: false).lastPathComponent
        instance.mimeType = path.mimeType()
        return instance
    }

    public static func fromData(_ data: Data, filename: String, mimeType: String) -> Payload {
        let instance = Payload()
        instance.filename = filename
        instance.mimeType = mimeType
        instance.data = data
        return instance
    }

    public static func fromBuffer(_ buffer: ByteBuffer, filename: String, mimeType: String) -> Payload {
        let instance = Payload()
        instance.filename = filename
        instance.mimeType = mimeType
        instance.data = buffer
        return instance
    }

    public static func fromString(_ data: String) -> Payload {
        let instance = Payload()
        instance.data = data
        return instance
    }

    public static func fromJson(_ data: [String: Any?]) throws -> Payload {
        let instance = Payload()
        let string = try JSONSerialization.data(withJSONObject: data)
        let json = String(data: string, encoding: .utf8)
        instance.data = json
        return instance
    }

    public func toString() throws -> String {
        return try convertDataTo(String.self)
    }

    public func toData() throws -> Data {
        return try convertDataTo(Data.self)
    }

    public func toByteBuffer() throws -> ByteBuffer {
        return try convertDataTo(ByteBuffer.self)
    }

    public func toMap() throws -> [String: Any?] {
        guard let stringData = try? toData() else {
            throw Error.invalidType("Payload can not be converted to a map")
        }
        return try JSONSerialization.jsonObject(with: stringData) as! [String: Any?]
    }

    private func convertDataTo<T>(_ type: T.Type) throws -> T {
        guard let data = self.data else {
            throw Error.invalidType("Payload can not be converted to \(T.self)")
        }

        switch (T.self, data) {
        case (is String.Type, let data as String):
            return data as! T
        case (is String.Type, let data as Data):
            return String(data: data, encoding: .utf8) as! T
        case (is String.Type, let data as ByteBuffer):
            return String(buffer: data) as! T
        case (is Data.Type, let data as String):
            return data.data(using: .utf8)! as! T
        case (is Data.Type, let data as Data):
            return data as! T
        case (is Data.Type, let data as ByteBuffer):
            return Data(buffer: data) as! T
        case (is ByteBuffer.Type, let data as String):
            return ByteBuffer(string: data) as! T
        case (is ByteBuffer.Type, let data as Data):
            return ByteBuffer(data: data) as! T
        case (is ByteBuffer.Type, let data as ByteBuffer):
            return data as! T
        default:
            throw Error.invalidType("Payload can not be converted to \(T.self)")
        }
    }
}
