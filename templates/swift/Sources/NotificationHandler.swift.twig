import SwiftUI
import JSONCodable
import FirebaseCore
import FirebaseMessaging
import AsyncHTTPClient

open class NotificationHandler {
    public static let shared = NotificationHandler()

    public var fcmEnabled = true

    internal var client: Client? = nil
    internal var account: Account? = nil
    internal var providerId: String? = nil

    public func setup(_ application: UIApplication, delegate: AppwriteDelegate) {
        FirebaseApp.configure()

        FirebaseMessaging.Messaging.messaging().delegate = delegate

        UNUserNotificationCenter.current().delegate = delegate

        let authOptions: UNAuthorizationOptions = [.alert, .badge, .sound]

        UNUserNotificationCenter.current().requestAuthorization(
            options: authOptions,
            completionHandler: { _, _ in }
        )

        NotificationCenter.default.addObserver(
            self,
            selector: #selector(tokenRefreshNotification),
            name: Notification.Name.MessagingRegistrationTokenRefreshed,
            object: nil
        )

        Client.cookieListener = { (existing, new) in
            Task {
                await self.updateTarget(
                    existingCookies: existing,
                    newCookies: new,
                    token: UserDefaults.standard.string(forKey: "pushToken") ?? ""
                )
            }
        }

        application.registerForRemoteNotifications()
    }

    public func handleToken(_ token: Data) {
        if (fcmEnabled) {
            FirebaseMessaging.Messaging.messaging().apnsToken = token
        }

        let identifier = String(data: token, encoding: .utf8) ?? ""

        Task {
            await self.updateTarget(
                existingCookies: [],
                newCookies: [],
                token: identifier
            )
        }
    }

    public func updateTarget(
        existingCookies: [String],
        newCookies: [String],
        token: String
    ) async {
        if (client == nil) {
            return
        }

        if (account == nil) {
            account = Account(client!)
        }

        let currentToken = UserDefaults.standard.string(forKey: "pushToken")
        var currentTargetId = UserDefaults.standard.string(forKey: "targetId") ?? ""

        var existing = [String]()
        if (existingCookies.isEmpty) {
            let domain = URL(string: client!.endPoint)!.host!
            let cookies = UserDefaults.standard.stringArray(forKey: domain) ?? []

            cookies.forEach {
                existing.append($0)
            }
        }

        var existingUser: [String: Any]? = nil
        if (existing.isEmpty && !newCookies.isEmpty) {
            existingUser = try? await request(
                method: "GET",
                path: "/account",
                headers: ["cookie": newCookies.joined(separator: "; ")]
            )
        } else if (!existing.isEmpty) {
            existingUser = try? await request(
                method: "GET",
                path: "/account",
                headers: ["cookie": existingCookies.joined(separator: "; ")]
            )
        }

        if (existingUser == nil) {
            return
        }

        var newUser: [String: Any]? = nil
        if (!newCookies.isEmpty) {
            newUser = try? await request(
                method: "GET",
                path: "/account",
                headers: ["cookie": newCookies.joined(separator: "; ")]
            )
        }

        var existingUserId = existingUser?["$id"] as? String
        var newUserId = newUser?["$id"] as? String

        if (
            token == currentToken
            && (!existingCookies.isEmpty && existingUserId == newUserId)
        ) {
            return
        }

        UserDefaults.standard.set(token, forKey: "pushToken")

        if (!existing.isEmpty && existingUserId != newUserId) {
            if (!currentTargetId.isEmpty) {
                 let result = try? await request(
                    method: "DELETE",
                    path: "/account/targets/$currentTargetId/push",
                    headers: ["cookie": existing.joined(separator: "; ")]
                )

                if (result == nil) {
                    return
                }

                UserDefaults.standard.removeObject(forKey: "targetId")
                currentTargetId = ""
            }
        }

        let target: [String: Any]?

        var params = [
            "targetId": ID.unique(),
            "identifier": token
        ]

        if (providerId != nil) {
            params["providerId"] = providerId!
        }

        if ((currentTargetId.isEmpty && existing.isEmpty) || existingUserId != newUserId) {
            target = try? await request(
                method: "POST",
                path: "/account/targets/push",
                headers: ["cookie": newCookies.joined(separator: "; ")],
                body: params
            )
        } else {
            target = try? await request(
                method: "POST",
                path: "/account/targets/push",
                headers: ["cookie": existing.joined(separator: "; ")],
                body: params
            )
        }

        if (target == nil) {
            return
        }

        UserDefaults.standard.set(target?["$id"] ?? "", forKey: "targetId")
    }

    @objc func tokenRefreshNotification(_ notification: Notification) {
        if let refreshedToken = FirebaseMessaging.Messaging.messaging().fcmToken {
            print("Got a fresh token: \(refreshedToken)")
        }
    }

    private func request(
        method: String,
        path: String,
        headers: [String: String],
        body: [String: Any]? = nil
    ) async throws -> [String: Any]? {
        var request = HTTPClientRequest(url: client!.endPoint + path)

        request.method = .RAW(value: method)

        for (key, value) in client!.headers.merging(headers, uniquingKeysWith: { $1 }) {
            request.headers.add(name: key, value: value)
        }

        let json = try JSONSerialization.data(withJSONObject: body as Any, options: [])

        request.body = .bytes(json)

        let response = try await client!.http.execute(
            request,
            timeout: .seconds(30)
        )

        let data = try await response.body.collect(upTo: Int.max)
        let dict = try JSONSerialization.jsonObject(with: data) as? [String: Any]

        return dict
    }
}
