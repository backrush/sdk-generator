package io.appwrite

import android.Manifest
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.pm.PackageManager
import android.os.Build
import android.util.Log
import androidx.annotation.RequiresApi
import androidx.core.app.NotificationCompat
import com.google.android.gms.tasks.OnCompleteListener
import com.google.firebase.messaging.FirebaseMessaging
import com.google.firebase.messaging.FirebaseMessagingService
import com.google.firebase.messaging.RemoteMessage
import io.appwrite.exceptions.AppwriteException
import io.appwrite.extensions.onNotificationReceived
import io.appwrite.models.Notification
import io.appwrite.services.Account
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch
import kotlin.properties.Delegates

class NotificationHandler : FirebaseMessagingService() {

    companion object {
        internal const val TARGET_NOT_FOUND = "user_target_not_found"

        /**
         * Should the notification be automatically displayed if the app is in the foreground
         */
        var displayForeground = true

        /**
         * The icon to display in the notification
         */
        var displayIcon by Delegates.notNull<Int>()

        /**
         * Should the notification be automatically canceled when the user clicks on it
         */
        var autoCancel = false

        /**
         * The intent to fire when the user clicks on the notification
         */
        var contentIntent: PendingIntent? = null

        /**
         * The channel id to use for the notification
         */
        @RequiresApi(Build.VERSION_CODES.N)
        var channelId = "io.appwrite.notifications"

        /**
         * The channel name to use for the notification
         */
        @RequiresApi(Build.VERSION_CODES.N)
        var channelName = "All Notifications"

        /**
         * The channel description to use for the notification
         */
        @RequiresApi(Build.VERSION_CODES.N)
        var channelDescription = "All notifications"

        /**
         * The channel importance to use for the notification
         */
        @RequiresApi(Build.VERSION_CODES.N)
        var channelImportance = NotificationManager.IMPORTANCE_DEFAULT
    }

    private val job = Job()
    private val scope = CoroutineScope(job + Dispatchers.IO)

    private val globalPrefs = getSharedPreferences(Client.GLOBAL_PREFS, Context.MODE_PRIVATE)
    private val cookiePrefs = getSharedPreferences(Client.COOKIE_PREFS, Context.MODE_PRIVATE)

    private val client = Client(this)
    private val account = Account(client)

    init {
        displayIcon = resources.getIdentifier(
            "ic_launcher_foreground",
            "drawable",
            packageName
        )

        val initialKeys = cookiePrefs.all.keys

        cookiePrefs.registerOnSharedPreferenceChangeListener { prefs, _ ->
            if (prefs.all.keys.size < initialKeys.size) {
                return@registerOnSharedPreferenceChangeListener
            }

            FirebaseMessaging.getInstance().token.addOnCompleteListener(OnCompleteListener { task ->
                if (!task.isSuccessful) {
                    Log.w(javaClass.name, "Fetching FCM registration token failed", task.exception)
                    return@OnCompleteListener
                }

                val token = task.result
                if (token.isNullOrEmpty()) {
                    return@OnCompleteListener
                }

                onNewToken(token)
            })
        }
    }

    override fun onNewToken(token: String) {
        scope.launch {
            pushToken(token)
        }
    }

    override fun onMessageReceived(message: RemoteMessage) {
        super.onMessageReceived(message)

        // Fire callback before display so channel can be configured if needed
        onNotificationReceived(Notification(
            title = message.notification?.title ?: "",
            body = message.notification?.body ?: "",
            clickAction = message.notification?.clickAction ?: "",
            color = message.notification?.color ?: "",
            icon = message.notification?.icon ?: "",
            imageURL = message.notification?.imageUrl.toString(),
            sound = message.notification?.sound ?: "",
            data = message.data
        ))

        val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                channelId,
                channelName,
                channelImportance
            ).apply {
                description = channelDescription
            }

            // Recreate is a no-op if the channel already exists
            notificationManager.createNotificationChannel(channel)
        }

        if (message.notification != null && displayForeground) {
            val notification = NotificationCompat.Builder(this, "io.appwrite.notifications")
                .setSmallIcon(displayIcon)
                .setContentTitle(message.notification?.title)
                .setContentText(message.notification?.body)
                .setPriority(NotificationCompat.PRIORITY_DEFAULT)
                .setAutoCancel(autoCancel)
                .setContentIntent(contentIntent)
                .build()

            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                val hasPermission = packageManager.checkPermission(
                    Manifest.permission.POST_NOTIFICATIONS,
                    packageName
                ) == PackageManager.PERMISSION_GRANTED

                if (!hasPermission) {
                    Log.w(
                        javaClass.name,
                        "You need to add the POST_NOTIFICATIONS permission to your AndroidManifest.xml file"
                    )
                }
            }

            notificationManager.notify(message.hashCode(), notification)
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        job.cancel()
    }

    private suspend fun pushToken(token: String) {
        try {
            account.get()
        } catch (ex: AppwriteException) {
            return
        }

        var targetId = globalPrefs.getString("targetId", "") ?: ""

        var attempts = 3
        while (attempts > 0) {
            try {
                if (targetId.isEmpty()) {
                    val target = account.createPushTarget(ID.unique(), token)
                    globalPrefs.edit().putString("targetId", target.id).apply()
                } else {
                    account.updatePushTarget(targetId, token)
                }
                break
            } catch (ex: AppwriteException) {
                if (ex.type == TARGET_NOT_FOUND) {
                    globalPrefs.edit().remove("targetId").apply()
                    targetId = ""
                }

                attempts--

                if (attempts == 0) {
                    Log.e(javaClass.name, "Failed to push token", ex)
                }
            }
        }
    }
}