package io.appwrite

import android.Manifest
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.content.pm.PackageManager
import android.os.Build
import android.util.Log
import androidx.annotation.RequiresApi
import androidx.core.app.NotificationCompat
import com.google.android.gms.tasks.OnCompleteListener
import com.google.firebase.messaging.FirebaseMessaging
import com.google.firebase.messaging.FirebaseMessagingService
import com.google.firebase.messaging.RemoteMessage
import io.appwrite.exceptions.AppwriteException
import io.appwrite.extensions.onNotificationReceived
import io.appwrite.models.Notification
import io.appwrite.models.User
import io.appwrite.services.Account
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch
import kotlin.properties.Delegates

class NotificationHandler : FirebaseMessagingService() {

    companion object {
        internal const val ACTION_CLIENT_INIT = "io.appwrite.ACTION_CLIENT_INIT"
        internal const val TARGET_NOT_FOUND = "user_target_not_found"

        internal var client: Client? = null
        internal var account: Account? = null
        internal var providerId: String? = null

        /**
         * Should notifications be automatically displayed if the app is in the foreground
         */
        var displayForeground = true

        /**
         * The icon to display in the notification
         */
        var displayIcon by Delegates.notNull<Int>()

        /**
         * Should the notification be automatically canceled when the user clicks on it
         */
        var autoCancel = false

        /**
         * The intent to fire when the user clicks on the notification
         */
        var contentIntent: PendingIntent? = null

        /**
         * The channel id to use for the notification
         */
        @RequiresApi(Build.VERSION_CODES.N)
        var channelId = "io.appwrite.notifications"

        /**
         * The channel name to use for the notification
         */
        @RequiresApi(Build.VERSION_CODES.N)
        var channelName = "All Notifications"

        /**
         * The channel description to use for the notification
         */
        @RequiresApi(Build.VERSION_CODES.N)
        var channelDescription = "All notifications"

        /**
         * The channel importance to use for the notification
         */
        @RequiresApi(Build.VERSION_CODES.N)
        var channelImportance = NotificationManager.IMPORTANCE_DEFAULT
    }

    private val job = Job()
    private val scope = CoroutineScope(job + Dispatchers.IO)

    private lateinit var globalPrefs: SharedPreferences

    private val listener = SharedPreferences.OnSharedPreferenceChangeListener { _, _ ->
        Log.d(javaClass.name, "CookiePrefs changed")

        FirebaseMessaging.getInstance().token.addOnCompleteListener(OnCompleteListener { task ->
            Log.d(javaClass.name, "Fetching FCM registration token")

            if (!task.isSuccessful) {
                Log.w(javaClass.name, "Fetching FCM registration token failed", task.exception)
                return@OnCompleteListener
            }

            val token = task.result
            if (token.isNullOrEmpty()) {
                return@OnCompleteListener
            }

            onNewToken(token)
        })
    }

    override fun getStartCommandIntent(originalIntent: Intent?): Intent {
        if (originalIntent?.action == ACTION_CLIENT_INIT) {
            return originalIntent
        }

        return super.getStartCommandIntent(originalIntent)
    }

    override fun handleIntent(intent: Intent?) {
        if (intent?.action == ACTION_CLIENT_INIT) {
            onClientInit()
            return
        }

        super.handleIntent(intent)
    }

    override fun onCreate() {
        super.onCreate()

        globalPrefs = applicationContext.getSharedPreferences(
            Client.GLOBAL_PREFS,
            Context.MODE_PRIVATE
        )

        displayIcon = resources.getIdentifier(
            "ic_launcher_foreground",
            "drawable",
            packageName
        )

        if (client != null) {
            // Make sure that the listener is registered if it was reclaimed since init
            client?.cookiePrefs?.registerOnSharedPreferenceChangeListener(listener)
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        job.cancel()
    }

    override fun onNewToken(token: String) {
        Log.d(javaClass.name, "FCM registration token: $token")

        scope.launch {
            pushToken(token)
        }
    }

    override fun onMessageReceived(message: RemoteMessage) {
        super.onMessageReceived(message)

        Log.d(javaClass.name, "Message received!")

        // Fire callback before display so channel can be configured if needed
        onNotificationReceived(
            Notification(
                title = message.notification?.title ?: "",
                body = message.notification?.body ?: "",
                clickAction = message.notification?.clickAction ?: "",
                color = message.notification?.color ?: "",
                icon = message.notification?.icon ?: "",
                imageURL = message.notification?.imageUrl.toString(),
                sound = message.notification?.sound ?: "",
                data = message.data
            )
        )

        val notificationManager =
            getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                channelId,
                channelName,
                channelImportance
            ).apply {
                description = channelDescription
            }

            // Recreate is a no-op if the channel already exists
            notificationManager.createNotificationChannel(channel)
        }

        if (message.notification != null && displayForeground) {
            val builder = NotificationCompat.Builder(this, "io.appwrite.notifications")
                .setContentTitle(message.notification?.title)
                .setContentText(message.notification?.body)
                .setPriority(NotificationCompat.PRIORITY_DEFAULT)
                .setAutoCancel(autoCancel)
                .setContentIntent(contentIntent)

            if (displayIcon != 0) {
                builder.setSmallIcon(displayIcon)
            }

            val notification = builder.build()


            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                val hasPermission = packageManager.checkPermission(
                    Manifest.permission.POST_NOTIFICATIONS,
                    packageName
                ) == PackageManager.PERMISSION_GRANTED

                if (!hasPermission) {
                    Log.w(
                        javaClass.name,
                        "You need to add the POST_NOTIFICATIONS permission to your AndroidManifest.xml file"
                    )
                }
            }

            notificationManager.notify(message.hashCode(), notification)
        }
    }

    private fun onClientInit() {
        Log.d(javaClass.name, "Client initialized")

        if (client == null) {
            Log.e(javaClass.name, "Client not initialized")
            return
        }
        if (account == null) {
            account = Account(client!!)
        }

        client?.cookiePrefs?.registerOnSharedPreferenceChangeListener(listener)
    }

    private suspend fun pushToken(token: String) {
        if (client == null) {
            Log.w(javaClass.name, "Client not initialized, skipping push")
            return
        }

        val currentToken = globalPrefs.getString("fcmToken", "") ?: ""
        val currentUserId = globalPrefs.getString("userId", "") ?: ""
        var currentTargetId = globalPrefs.getString("targetId", "") ?: ""

        if (token == currentToken) {
            Log.d(javaClass.name, "New token matches current token, skipping push")
            return
        }

        globalPrefs.edit().putString("fcmToken", token).apply()

        val user: User<Map<String, Any>>?

        try {
            user = account?.get()
        } catch (ex: AppwriteException) {
            Log.w(javaClass.name, "Not logged in, skipping push", ex)
            return
        }

        try {
            if (user?.id != currentUserId) {
                Log.d(javaClass.name, "User changed, re-creating target")

                if (currentTargetId.isNotEmpty()) {
                    account?.deletePushTarget(currentTargetId)
                    currentTargetId = ""
                    globalPrefs.edit().remove("targetId").apply()
                }

                globalPrefs.edit().putString("userId", user?.id ?: "").apply()
            }
        } catch (ex: AppwriteException) {
            Log.e(javaClass.name, "Failed to delete existing target", ex)
        }

        try {
            if (currentTargetId.isEmpty()) {
                Log.d(javaClass.name, "Creating new push target")
                val target = account!!.createPushTarget(ID.unique(), token, providerId)
                globalPrefs.edit().putString("targetId", target.id).apply()
                Log.d(javaClass.name, "Push token created successfully")
            } else {
                Log.d(javaClass.name, "Updating existing push target")
                account!!.updatePushTarget(currentTargetId, token)
                Log.d(javaClass.name, "Push token updated successfully")
            }
        } catch (ex: AppwriteException) {
            Log.e(javaClass.name, "Failed to push token", ex)

            if (ex.type == TARGET_NOT_FOUND) {
                globalPrefs.edit().remove("targetId").apply()
            }
        }
    }
}