package io.appwrite

import android.Manifest
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.content.pm.PackageManager
import android.os.Build
import android.util.Log
import androidx.annotation.RequiresApi
import androidx.core.app.NotificationCompat
import com.google.android.gms.tasks.OnCompleteListener
import com.google.firebase.messaging.FirebaseMessaging
import com.google.firebase.messaging.FirebaseMessagingService
import com.google.firebase.messaging.RemoteMessage
import io.appwrite.exceptions.AppwriteException
import io.appwrite.extensions.onNotificationReceived
import io.appwrite.models.Notification
import io.appwrite.models.User
import io.appwrite.services.Account
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
import kotlin.properties.Delegates

class NotificationHandler : FirebaseMessagingService() {

    companion object {
        internal const val ACTION_CLIENT_INIT = "io.appwrite.ACTION_CLIENT_INIT"

        internal var client: Client? = null
        internal var account: Account? = null
        internal var providerId: String? = null

        internal var cookieListener: SharedPreferences.OnSharedPreferenceChangeListener? = null

        /**
         * Should notifications be automatically displayed if the app is in the foreground
         */
        var displayForeground = true

        /**
         * The icon to display in the notification
         */
        var displayIcon by Delegates.notNull<Int>()

        /**
         * Should the notification be automatically canceled when the user clicks on it
         */
        var autoCancel = false

        /**
         * The intent to fire when the user clicks on the notification
         */
        var contentIntent: PendingIntent? = null

        /**
         * The channel id to use for the notification
         */
        @RequiresApi(Build.VERSION_CODES.N)
        var channelId = "io.appwrite.notifications"

        /**
         * The channel name to use for the notification
         */
        @RequiresApi(Build.VERSION_CODES.N)
        var channelName = "All Notifications"

        /**
         * The channel description to use for the notification
         */
        @RequiresApi(Build.VERSION_CODES.N)
        var channelDescription = "All notifications"

        /**
         * The channel importance to use for the notification
         */
        @RequiresApi(Build.VERSION_CODES.N)
        var channelImportance = NotificationManager.IMPORTANCE_DEFAULT
    }

    private lateinit var mutex: Mutex

    private lateinit var globalPrefs: SharedPreferences

    override fun getStartCommandIntent(originalIntent: Intent?): Intent {
        if (originalIntent?.action == ACTION_CLIENT_INIT) {
            return originalIntent
        }

        return super.getStartCommandIntent(originalIntent)
    }

    override fun handleIntent(intent: Intent?) {
        if (intent?.action == ACTION_CLIENT_INIT) {
            onClientInit()
            return
        }

        super.handleIntent(intent)
    }

    override fun onCreate() {
        super.onCreate()

        globalPrefs = applicationContext.getSharedPreferences(
            Client.GLOBAL_PREFS, Context.MODE_PRIVATE
        )

        displayIcon = resources.getIdentifier(
            "ic_launcher_foreground", "drawable", packageName
        )

        mutex = Mutex()

        if (cookieListener == null) {
            cookieListener = SharedPreferences.OnSharedPreferenceChangeListener { _, _ ->
                FirebaseMessaging.getInstance().token.addOnCompleteListener(OnCompleteListener { task ->
                    if (!task.isSuccessful) {
                        Log.w(javaClass.name, "Fetching FCM registration token failed", task.exception)
                        return@OnCompleteListener
                    }

                    val token = task.result
                    if (token.isNullOrEmpty()) {
                        return@OnCompleteListener
                    }

                    onNewToken(token)
                })
            }
        }

        if (client != null) {
            client?.cookiePrefs?.registerOnSharedPreferenceChangeListener(cookieListener)
        }
    }

    override fun onNewToken(token: String) {
        runBlocking {
            mutex.withLock {
                pushToken(token)
            }
        }
    }

    override fun onMessageReceived(message: RemoteMessage) {
        super.onMessageReceived(message)

        // Fire callbacks before display so handler can be configured if needed
        onNotificationReceived(
            Notification(
                title = message.notification?.title ?: "",
                body = message.notification?.body ?: "",
                clickAction = message.notification?.clickAction ?: "",
                color = message.notification?.color ?: "",
                icon = message.notification?.icon ?: "",
                imageURL = message.notification?.imageUrl?.toString() ?: "",
                sound = message.notification?.sound ?: "",
                data = message.data
            )
        )

        val notificationManager =
            getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                channelId, channelName, channelImportance
            ).apply {
                description = channelDescription
            }

            // Recreate is a no-op if the channel already exists
            notificationManager.createNotificationChannel(channel)
        }

        if (message.notification != null && displayForeground) {
            val builder = NotificationCompat.Builder(this, "io.appwrite.notifications")
                .setContentTitle(message.notification?.title)
                .setContentText(message.notification?.body)
                .setPriority(NotificationCompat.PRIORITY_DEFAULT).setAutoCancel(autoCancel)
                .setContentIntent(contentIntent)

            if (displayIcon != 0) {
                builder.setSmallIcon(displayIcon)
            }

            val notification = builder.build()

            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                val hasPermission = packageManager.checkPermission(
                    Manifest.permission.POST_NOTIFICATIONS,
                    packageName
                ) == PackageManager.PERMISSION_GRANTED

                if (!hasPermission) {
                    Log.w(javaClass.name, "Permission denied, make sure you have requested the POST_NOTIFICATIONS permission")
                }
            }

            notificationManager.notify(message.hashCode(), notification)
        }
    }

    private fun onClientInit() {
        if (client == null) {
            return
        }

        if (account == null) {
            account = Account(client!!)
        }

        client?.cookiePrefs?.registerOnSharedPreferenceChangeListener(cookieListener)
    }

    private suspend fun pushToken(token: String) {
        if (client == null) {
            return
        }

        val currentToken = globalPrefs.getString("fcmToken", "") ?: ""
        val currentUserId = globalPrefs.getString("userId", "") ?: ""
        var currentTargetId = globalPrefs.getString("targetId", "") ?: ""

        val user: User<Map<String, Any>>?

        try {
            user = account?.get()
        } catch (ex: AppwriteException) {
            return
        }

        if (token == currentToken && user?.id == currentUserId) {
            return
        }

        globalPrefs.edit().putString("fcmToken", token).apply()

        try {
            if (user?.id != currentUserId) {
                if (currentTargetId.isNotEmpty()) {
                    account?.deletePushTarget(currentTargetId)
                    currentTargetId = ""
                    globalPrefs.edit().remove("targetId").apply()
                }

                globalPrefs.edit().putString("userId", user?.id ?: "").apply()
            }
        } catch (ex: AppwriteException) {
            Log.e(javaClass.name, "Failed to delete existing target", ex)
        }

        try {
            if (currentTargetId.isEmpty()) {
                val target = account!!.createPushTarget(ID.unique(), token, providerId)
                globalPrefs.edit().putString("targetId", target.id).apply()
            } else {
                account!!.updatePushTarget(currentTargetId, token)
            }
        } catch (ex: AppwriteException) {
            Log.e(javaClass.name, "Failed to push token", ex)
        }
    }
}