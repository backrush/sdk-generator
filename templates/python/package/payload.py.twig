import os
import json
import mimetypes
import re
from abc import ABC, abstractmethod
from typing import Union, Dict, List, Optional

class PayloadData(ABC):
    @abstractmethod
    def size(self) -> int:
        pass

    @abstractmethod
    def read(self, offset: int = 0, length: Optional[int] = None) -> bytes:
        pass

class FileData(PayloadData):
    def __init__(self, path: str, filename: Optional[str] = None, mime_type: Optional[str] = None):
        if not os.path.exists(path):
            raise FileNotFoundError("File not found")
        self.path = path
        self.filename = filename or os.path.basename(path)
        self.mime_type = mime_type or mimetypes.guess_type(path)[0]

    def size(self) -> int:
        return os.path.getsize(self.data)

    def read(self, offset: int = 0, length: Optional[int] = None) -> bytes:
        with open(self.data, 'rb') as f:
            f.seek(offset)
            return f.read(length) if length is not None else f.read()

class MemoryData(PayloadData):
    def __init__(self, data: Union[str, bytes], filename: Optional[str] = None, mime_type: Optional[str] = None):
        self.data = data.encode() if isinstance(data, str) else data
        self.filename = filename
        self.mime_type = mime_type

    def size(self) -> int:
        return len(self.data)

    def read(self, offset: int = 0, length: Optional[int] = None) -> bytes:
        return self.data[offset:offset + length] if length is not None else self.data[offset:]

class Payload:
    def __init__(self, data: PayloadData):
        self._data = data

    @classmethod
    def from_path(cls, path: str, filename: Optional[str] = None, mime_type: Optional[str] = None):
        return cls(FileData(path, filename=filename, mime_type=mime_type))

    @classmethod
    def from_binary(cls, binary: bytes, filename: Optional[str] = None, mime_type: Optional[str] = None):
        return cls(MemoryData(binary, filename=filename, mime_type=mime_type))

    @classmethod
    def from_json(cls, obj: Union[Dict, List], filename: Optional[str] = None, mime_type: str = 'application/json'):
        json_data = json.dumps(obj) if isinstance(obj, (dict, list)) else obj
        return cls(MemoryData(json_data, filename=filename, mime_type=mime_type))

    @classmethod
    def from_string(cls, string: str, filename: Optional[str] = None, mime_type: str = 'text/plain'):
        return cls(MemoryData(string, filename=filename, mime_type=mime_type))

    def to_string(self) -> str:
        return self._data.read().decode()

    __str__ = to_binary = to_string

    def to_json(self) -> Union[Dict, List]:
        return json.loads(self._data.read())

    @staticmethod
    def handle_form_data(boundary: str, response_body: str) -> Dict:
        parts = response_body.split(boundary)
        data = {}
        for part in parts:
            match = re.search(r'name="?(\w+)"?', part)
            if match:
                name = match.group(1)
                content = part.split('\r\n\r\n', 1)[-1].strip()
                data[name] = content

        data['responseStatusCode'] = int(data.get('responseStatusCode', 0))
        data['duration'] = float(data.get('duration', 0))
        data['responseBody'] = Payload.from_string(data.get('responseBody', ''))
        return data