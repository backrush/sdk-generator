import re
from typing import Dict, Union, Optional
from dataclasses import dataclass
from .payload import Payload

extension_to_content_type = {
    # Text
    'txt': 'text/plain',
    'html': 'text/html',
    'htm': 'text/html',
    'css': 'text/css',
    'csv': 'text/csv',

    # Image
    'jpg': 'image/jpeg',
    'jpeg': 'image/jpeg',
    'png': 'image/png',
    'gif': 'image/gif',
    'bmp': 'image/bmp',
    'webp': 'image/webp',
    'svg': 'image/svg+xml',
    'ico': 'image/x-icon',

    # Audio
    'mp3': 'audio/mpeg',
    'wav': 'audio/wav',
    'ogg': 'audio/ogg',

    # Video
    'mp4': 'video/mp4',
    'avi': 'video/x-msvideo',
    'webm': 'video/webm',

    # Application
    'pdf': 'application/pdf',
    'doc': 'application/msword',
    'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    'xls': 'application/vnd.ms-excel',
    'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    'ppt': 'application/vnd.ms-powerpoint',
    'pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
    'zip': 'application/zip',
    'rar': 'application/x-rar-compressed',
    'tar': 'application/x-tar',
    'gz': 'application/gzip',
    '7z': 'application/x-7z-compressed',

    # Programming
    'js': 'application/javascript',
    'json': 'application/json',
    'xml': 'application/xml',
    'py': 'text/x-python',
    'java': 'text/x-java-source',
    'c': 'text/x-c',
    'cpp': 'text/x-c++',
    'cs': 'text/x-csharp',
    'php': 'application/x-httpd-php',
    'rb': 'application/x-ruby',
    'go': 'text/x-go',
    'sql': 'application/sql',

    # Fonts
    'ttf': 'font/ttf',
    'otf': 'font/otf',
    'woff': 'font/woff',
    'woff2': 'font/woff2',

    # Other
    'md': 'text/markdown',
    'yaml': 'application/x-yaml',
    'yml': 'application/x-yaml',
    'ics': 'text/calendar',
    'vcf': 'text/vcard',
}

@dataclass
class FormDataValue:
    headers: Dict[str, str]
    body: Union[str, bytes]

class FormData:
    def __init__(self, values: Dict[str, FormDataValue] = None):
        self.values = values or {}

    def get(self, name: str) -> Optional[FormDataValue]:
        return self.values.get(name)

    def set(self, name: str, value: Union[str, bytes], filename: Optional[str] = None):
        if isinstance(value, bytes):
            self.set_file(name, value, filename)
        else:
            self.values[name] = FormDataValue(
                headers={
                    "Content-Disposition": f'form-data; name="{name}"'
                },
                body=value
            )

    def set_file(self, name: str, file: bytes, filename: Optional[str] = None):
        disposition = f'form-data; name="{name}"'
        if filename:
            disposition += f'; filename="{filename}"'
        
        headers = {
            "Content-Disposition": disposition
        }

        if filename:
            extension = filename.split('.')[-1]
            content_type = extension_to_content_type.get(extension)
            if content_type:
                headers["Content-Type"] = content_type

        self.values[name] = FormDataValue(headers=headers, body=file)

    @staticmethod
    def from_multipart(body: str, boundary: Optional[str] = None) -> 'FormData':
        if not boundary:
            boundary_match = re.search(r'boundary=(?:"([^"]+)"|([^;]+))', body)
            if not boundary_match:
                raise ValueError("No boundary found in Content-Type")
            boundary = boundary_match.group(1) or boundary_match.group(2)

        raw_parts = re.split(f'--{boundary}(?:--)?\\r?\\n', body)[1:-1]

        parsed_parts = {}
        for raw_part in raw_parts:
            value = FormData.parse_part(raw_part)
            name = FormData.parse_value_name(value)
            parsed_parts[name] = value

        return FormData(parsed_parts)

    @staticmethod
    def parse_part(raw_part: str) -> FormDataValue:
        raw_headers, body = re.split(r'\r?\n\r?\n', raw_part, 1)

        headers = {}
        for header in raw_headers.split('\r\n'):
            key, value = header.split(': ', 1)
            headers[key.lower()] = value

        return FormDataValue(headers=headers, body=body)

    def to_multipart_string(self, boundary: Optional[str] = None) -> str:
        if not boundary:
            import random
            boundary = f"----{''.join(random.choices('abcdefghijklmnopqrstuvwxyz0123456789', k=32))}"

        parts = [FormData.value_to_multipart_string(value, boundary) for value in self.values.values()]
        return ''.join(parts) + f'--{boundary}--\r\n'

    async def to_object(self):
        obj = {}

        for name, value in self.values.items():
            if name == "body":
                value.body = value.body.encode() if isinstance(value.body, str) else value.body

            if isinstance(value.body, bytes):
                obj[name] = Payload.from_binary(value.body, name)
            else:
                obj[name] = value.body

        return obj

    @staticmethod
    def parse_value_name(part: FormDataValue) -> str:
        disposition = part.headers.get("content-disposition")
        if not disposition:
            raise ValueError("Part is missing Content-Disposition header")

        name_match = re.search(r'name="([^"]+)"', disposition)
        if not name_match:
            raise ValueError("Content-Disposition header is missing name")

        return name_match.group(1)

    @staticmethod
    def parse_value_filename(part: FormDataValue) -> Optional[str]:
        disposition = part.headers.get("content-disposition")
        if not disposition:
            raise ValueError("Part is missing Content-Disposition header")

        filename_match = re.search(r'filename="([^"]+)"', disposition)
        return filename_match.group(1) if filename_match else None

    @staticmethod
    def value_to_multipart_string(value: FormDataValue, boundary: str) -> str:
        headers = '\r\n'.join(f'{key}: {val}' for key, val in value.headers.items())
        return f'--{boundary}\r\n{headers}\r\n\r\n{value.body}\r\n'
