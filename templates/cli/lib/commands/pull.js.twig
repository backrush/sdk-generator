const { Command } = require("commander");
const inquirer = require("inquirer");
const { teamsCreate, teamsList } = require("./teams");
const { projectsCreate } = require("./projects");
const { databasesGet, databasesListCollections, databasesList } = require("./databases");
const { storageListBuckets } = require("./storage");
const { sdkForConsole } = require("../sdks");
const { localConfig } = require("../config");
const { paginate } = require("../paginate");
const { questionsPullProject, questionsPullCollection } = require("../questions");
const { success, log, actionRunner, commandDescriptions } = require("../parser");

const pull = new Command("pull")
    .description(commandDescriptions['pull'])
    .configureHelp({
        helpWidth: process.stdout.columns || 80
    })
    .action(actionRunner(async (_options, command) => {
        command.help();
    }));

const pullProject = async () => {
    const answers = await inquirer.prompt(questionsPullProject)
    if (!answers.project) process.exit(1)

    localConfig.setProject(answers.project.id, answers.project.name);
    success();
}

const pullCollection = async ({ all, databaseId } = {}) => {
    const databaseIds = [];

    if (databaseId) {
        databaseIds.push(databaseId);
    } else if (all) {
        let allDatabases = await databasesList({
            parseOutput: false
        })

        databaseIds.push(...allDatabases.databases.map((d) => d.$id));
    }

    if (databaseIds.length <= 0) {
        let answers = await inquirer.prompt(questionsPullCollection)
        if (!answers.databases) process.exit(1)
        databaseIds.push(...answers.databases);
    }

    for (const databaseId of databaseIds) {
        const database = await databasesGet({
            databaseId,
            parseOutput: false
        });

        localConfig.addDatabase(database);

        const { collections, total } = await paginate(databasesListCollections, {
            databaseId,
            parseOutput: false
        }, 100, 'collections');

        log(`Found ${total} collections`);

        collections.forEach(async collection => {
            log(`Fetching ${collection.name} ...`);
            localConfig.addCollection({
                ...collection,
                '$createdAt': undefined,
                '$updatedAt': undefined,
            });
        });
    }

    success();
}

const pullBucket = async () => {
    const { buckets } = await paginate(storageListBuckets, { parseOutput: false }, 100, 'buckets');

    log(`Found ${buckets.length} buckets`);

    buckets.forEach(async bucket => {
        log(`Fetching ${bucket.name} ...`);
        localConfig.addBucket(bucket);
    });

    success();
}

const pullTeam = async () => {
    const { teams } = await paginate(teamsList, { parseOutput: false }, 100, 'teams');

    log(`Found ${teams.length} teams`);

    teams.forEach(async team => {
        log(`Fetching ${team.name} ...`);
        const { total, $updatedAt, $createdAt, prefs, ...rest } = team;
        localConfig.addTeam(rest);
    });

    success();
}

pull
    .command("project")
    .description("Pulling your {{ spec.title|caseUcfirst }} project")
    .action(actionRunner(pullProject));

pull
    .command("collection")
    .description("Pulling your {{ spec.title|caseUcfirst }} collections")
    .option(`--databaseId <databaseId>`, `Database ID`)
    .option(`--all`, `Flag to pullialize all databases`)
    .action(actionRunner(pullCollection))

pull
    .command("bucket")
    .description("Pulling your Appwrite buckets")
    .action(actionRunner(pullBucket))

pull
    .command("team")
    .description("Pulling your Appwrite teams")
    .action(actionRunner(pullTeam))

module.exports = {
    pull,
};
