const Tail = require('tail').Tail;
const EventEmitter = require('node:events');
const ignore = require("ignore");
const tar = require("tar");
const fs = require("fs");
const childProcess = require('child_process');
const chokidar = require('chokidar');
const inquirer = require("inquirer");
const path = require("path");
const { Command } = require("commander");
const { localConfig, globalConfig } = require("../config");
const { paginate } = require('../paginate');
const { functionsListVariables } = require('./functions');
const { questionsRunFunctions } = require("../questions");
const { actionRunner, success, log, error, commandDescriptions, drawTable } = require("../parser");
const { systemHasCommand, isPortTaken, getAllFiles } = require('../utils');

const activeDockerIds = {};

const openRuntimesVersion = 'v3';
const systemTools = {
    'node': {
        isCompiled: false,
        startCommand: "node src/server.js",
        commands: [
            { command: "node", docs: "https://nodejs.org/en/download/package-manager" },
            { command: "npm", docs: "https://nodejs.org/en/download/package-manager" },
        ],
        dependencyFiles: [ "package.json", "package-lock.json" ]
    },
    // TODO: Add all runtime needs
};

// TODO: Logs dont work

const Queue = {
    files: [],
    locked: false,
    events: new EventEmitter(),
    push(file) {
        if(!this.files.includes(file)) {
            this.files.push(file);
        }

        if(!this.locked) {
            this.events.emit('reload', { files: this.files });
        }
    },
    lock() {
        this.files = [];
        this.locked = true;
    },
    unlock() {
        this.locked = false;
        if(this.files.length > 0) {
            this.events.emit('reload', { files: this.files });
        }
    }
};

async function dockerStop(id) {
    delete activeDockerIds[id];    
    const stopProcess = childProcess.spawn('docker', ['rm', '--force', id], {
        stdio: 'pipe',
    });

    await new Promise((res) => { stopProcess.on('close', res) });
}

async function dockerPull(func) {
    return; // TODO: Remove
    log('Pulling Docker image of function runtime ...');

    const [ runtimeName, runtimeVersion ] = func.runtime.split('-', 2);
    const imageName = `openruntimes/${runtimeName}:${openRuntimesVersion}-${runtimeVersion}`;

    const pullProcess = childProcess.spawn('docker', ['pull', imageName], {
        stdio: 'pipe',
        pwd: path.join(process.cwd(), func.path)
    });

    pullProcess.stderr.on('data', (data) => {
        process.stderr.write(`\n${data}$ `);
    });

    await new Promise((res) => { pullProcess.on('close', res) });
}

async function dockerBuild(func, variables) {
    log('Building function using Docker engine ...');

    const [ runtimeName, runtimeVersion ] = func.runtime.split('-', 2);
    const imageName = `openruntimes/${runtimeName}:${openRuntimesVersion}-${runtimeVersion}`;

    const functionDir = path.join(process.cwd(), func.path);

    const id = `${new Date().getTime().toString(16)}${Math.round(Math.random() * 1000000000).toString(16)}`;

    const params = [ 'run' ];
    params.push('--name', id);
    params.push('-v', `${functionDir}/:/mnt/code:rw`);
    params.push('-e', 'APPWRITE_ENV=development');
    params.push('-e', 'OPEN_RUNTIMES_ENV=development');
    params.push('-e', 'OPEN_RUNTIMES_SECRET=');
    params.push('-e', `OPEN_RUNTIMES_ENTRYPOINT=${func.entrypoint}`);

    for(const v of variables) {
        params.push('-e', `${v.key}=${v.value}`);
    }

    params.push(imageName, 'sh', '-c', `helpers/build.sh "${func.commands}"`);

    const buildProcess = childProcess.spawn('docker', params, {
        stdio: 'pipe',
        pwd: functionDir
    });

    buildProcess.stdout.on('data', (data) => {
        process.stdout.write(`\n${data}`);
    });
    
    buildProcess.stderr.on('data', (data) => {
        process.stderr.write(`\n${data}`);
    });

    await new Promise((res) => { buildProcess.on('close', res) });

    const copyPath = path.join(process.cwd(), func.path, '.appwrite', 'build.tar.gz');
    const copyDir = path.dirname(copyPath);
    if (!fs.existsSync(copyDir)) {
        fs.mkdirSync(copyDir, { recursive: true });
    }

    const copyProcess = childProcess.spawn('docker', ['cp', `${id}:/mnt/code/code.tar.gz`, copyPath], {
        stdio: 'pipe',
        pwd: functionDir
    });

    await new Promise((res) => { copyProcess.on('close', res) });

    const cleanupProcess = childProcess.spawn('docker', ['rm', '--force', id], {
        stdio: 'pipe',
        pwd: functionDir
    });

    await new Promise((res) => { cleanupProcess.on('close', res) });

    delete activeDockerIds[id];

    const tempPath = path.join(process.cwd(), func.path, 'code.tar.gz');
    if (fs.existsSync(tempPath)) {
        fs.rmSync(tempPath, { force: true });
    } 
}

async function dockerStart(func, variables, port) {
   log('Starting function using Docker engine ...');

   log("Permissions, events, CRON and timeouts dont apply when running locally.");

   log('ðŸ’¡ Hint: Function automatically restarts when you edit your code.');

   success(`Visit http://localhost:${port}/ to execute your function.`);
   
    const [ runtimeName, runtimeVersion ] = func.runtime.split('-', 2);
    const imageName = `openruntimes/${runtimeName}:${openRuntimesVersion}-${runtimeVersion}`;

    const tool = systemTools[runtimeName];

    const functionDir = path.join(process.cwd(), func.path);

    const id = `${new Date().getTime().toString(16)}${Math.round(Math.random() * 1000000000).toString(16)}`;

    const params = [ 'run' ];
    params.push('--rm');
    params.push('-d');
    params.push('--name', id);
    params.push('-p', `${port}:3000`);
    params.push('-e', 'APPWRITE_ENV=development');
    params.push('-e', 'OPEN_RUNTIMES_ENV=development');
    params.push('-e', 'OPEN_RUNTIMES_SECRET=');

    for(const v of variables) {
        params.push('-e', `${v.key}=${v.value}`);
    }

    params.push('-v', `${functionDir}/.appwrite/logs.txt:/mnt/logs/dev_logs.log:rw`);
    params.push('-v', `${functionDir}/.appwrite/errors.txt:/mnt/logs/dev_errors.log:rw`);
    params.push('-v', `${functionDir}/.appwrite/build.tar.gz:/mnt/code/code.tar.gz:ro`);
    params.push(imageName, 'sh', '-c', `helpers/start.sh "${tool.startCommand}"`);
    
    childProcess.spawn('docker', params, {
        stdio: 'pipe',
        pwd: functionDir
    });

    activeDockerIds[id] = true;
}

async function dockerCleanup() {
    const ids = Object.keys(activeDockerIds);
    for await (const id of ids) {
        await dockerStop(id);
    }

    const functions = localConfig.getFunctions();
    for(const func of functions) {
        const appwritePath = path.join(process.cwd(), func.path, '.appwrite');
        if (fs.existsSync(appwritePath)) {
            fs.rmSync(appwritePath, { recursive: true, force: true });
        }

        const tempPath = path.join(process.cwd(), func.path, 'code.tar.gz');
        if (fs.existsSync(tempPath)) {
            fs.rmSync(tempPath, { force: true });
        }
    }
}

const runFunction = async ({ port, engine, functionId } = {}) => {
    // Selection
    if(!functionId) {
        const answers = await inquirer.prompt(questionsRunFunctions[0]);
        functionId = answers.function;
    }

    const functions = localConfig.getFunctions();
    const func = functions.find((f) => f.$id === functionId);
    if (!func) {
        throw new Error("Function '" + functionId + "' not found.")
    }

    const runtimeName = func.runtime.split('-')[0];
    const tool = systemTools[runtimeName];

    // Configuration: Port
    if(port) {
        port = +port;
    }

    if(isNaN(port)) {
        port = null;
    }

    if(port) {
        const taken = await isPortTaken(port);

        if(taken) {
            log(`Port ${port} is already used.`);
            port = null;
        }
    }

    if(!port) {
        const answers = await inquirer.prompt(questionsRunFunctions[1]);
        port = answers.port;
    }

    // Configuration: Engine
    if(engine !== "system" && engine !== "docker") {
        engine = null;
    }

    if(!engine) {
        const answers = await inquirer.prompt(questionsRunFunctions[2]);
        engine = answers.engine;
    }

    if(engine === 'docker') {
        log('ðŸ’¡ Hint: Using system is faster, but using Docker simulates the production environment precisely.');

        if(!systemHasCommand('docker')) {
            return error("Please install Docker first: https://docs.docker.com/engine/install/");
        }
    } else if(engine === 'system') {
        log('ðŸ’¡ Hint: Docker simulates the production environment precisely, but using system is faster');

        for(const command of tool.commands) {
            if(!systemHasCommand(command.command)) {
                return error(`Your system is missing command "${command.command}". Please install it first: ${command.docs}`);
            }
        }
    }

    // Settings
    const settings = {
        runtime: func.runtime,
        entrypoint: func.entrypoint,
        path: func.path,
        commands: func.commands,
    };

    log("Local function configuration:");
    drawTable([settings]);
    log('If you wish to change local settings, update appwrite.json file and rerun the command. To deploy the function, run: appwrite push function');

    await dockerCleanup();

    process.on('SIGINT', async () => {
        log('Cleaning up ...');
        await dockerCleanup();
        success();
        process.exit();
    });

    if(engine === "docker") {
        const logsPath = path.join(process.cwd(), func.path, '.appwrite/logs.txt');
        const errorsPath = path.join(process.cwd(), func.path, '.appwrite/errors.txt');

        if(!fs.existsSync(path.dirname(logsPath))) {
            fs.mkdirSync(path.dirname(logsPath), { recursive: true });
        }

        if (!fs.existsSync(logsPath)) {
            fs.writeFileSync(logsPath, '');
        }

        if (!fs.existsSync(errorsPath)) {
            fs.writeFileSync(errorsPath, '');
        }

        let variables = [];
        if (globalConfig.getEndpoint() === '' || globalConfig.getCookie() === '') {
            // TODO: Flag to disable
            error("No user is signed in. To sign in, run: appwrite login. Function will run locally, but will not have your function's environment variables set.");
        } else {
            const { variables: remoteVariables } = await paginate(functionsListVariables, {
                functionId: func['$id'],
                parseOutput: false
            }, 100, 'variables');

            remoteVariables.forEach((v) => {
                variables.push({
                    key: v.key,
                    value: v.value
                });
            });
        }

        await dockerPull(func);
        await dockerBuild(func, variables);
        await dockerStart(func, variables, port);

        new Tail(logsPath).on("line", function(data) {
            console.log(data);
        });
        new Tail(errorsPath).on("line", function(data) {
            console.log(data);
        });

        chokidar.watch('.', {
            cwd: path.join(process.cwd(), func.path),
            ignoreInitial: true,
            ignored: [ ...(func.ignore ?? []), 'code.tar.gz', '.appwrite', '.appwrite/', '.appwrite/*', '.appwrite/**', '.appwrite/*.*', '.appwrite/**/*.*' ]
        }).on('all', async (_event, filePath) => {
            Queue.push(filePath);
        });

        Queue.events.on('reload', async ({ files }) => {
            Queue.lock();

            log('Live-reloading due to file changes: ');
            for(const file of files) {
                log(`- ${file}`);
            }

            try {
                log('Stopping the function ...');

                for(const id in activeDockerIds) {
                    await dockerStop(id);
                }

                const dependencyFile = files.find((filePath) => tool.dependencyFiles.includes(filePath));
                if(tool.isCompiled || dependencyFile) {
                    log(`Rebuilding the function due to cange in ${dependencyFile} ...`);
                    await dockerBuild(func, variables);
                    await dockerStart(func, variables, port);
                } else {
                    log('Hot-swapping function files ...');
                    
                    const functionPath = path.join(process.cwd(), func.path);
                    const hotSwapPath = path.join(functionPath, '.appwrite/hot-swap');
                    const buildPath = path.join(functionPath, '.appwrite/build.tar.gz');

                    // Prepare temp folder
                    if (!fs.existsSync(hotSwapPath)) {
                        fs.mkdirSync(hotSwapPath, { recursive: true });
                    } else {
                        fs.rmSync(hotSwapPath, { recursive: true, force: true });
                        fs.mkdirSync(hotSwapPath, { recursive: true });
                    }

                    await tar
                        .extract({
                            gzip: true,
                            sync: true,
                            cwd: hotSwapPath,
                            file: buildPath
                        });

                    const ignorer = ignore();
                    ignorer.add('.appwrite');
                    if (func.ignore) {
                        ignorer.add(func.ignore);
                    }

                    const filesToCopy = getAllFiles(functionPath).map((file) => path.relative(functionPath, file)).filter((file) => !ignorer.ignores(file));
                    for(const f of filesToCopy) {
                        const filePath = path.join(hotSwapPath, f);
                        if (fs.existsSync(filePath)) {
                            fs.rmSync(filePath, { force: true });
                        } 

                        const fileDir = path.dirname(filePath);
                        if (!fs.existsSync(fileDir)) {
                            fs.mkdirSync(fileDir, { recursive: true });
                        }

                        const sourcePath = path.join(functionPath, f);
                        fs.copyFileSync(sourcePath, filePath);
                    }

                    await tar
                        .create({
                            gzip: true,
                            sync: true,
                            cwd: hotSwapPath,
                            file: buildPath
                        }, ['.']);
                    
                    fs.rmSync(hotSwapPath, { recursive: true, force: true });

                    await dockerStart(func, variables, port);
                }
            } catch(err) {
                console.error(err);
            } finally {
                Queue.unlock();
            }
        });
    }
}

const run = new Command("run")
    .alias("dev")
    .description(commandDescriptions['run'])
    .configureHelp({
        helpWidth: process.stdout.columns || 80
    })
    .action(actionRunner(async (_options, command) => {
        command.help();
    }));

run
    .command("function")
    .alias("functions")
    .description("Run functions in the current directory.")
    .option(`--functionId <functionId>`, `Function ID`)
    .option(`--port <port>`, `Local port`)
    .option(`--engine <engine>`, `Local engine, "system" or "docker"`)
    // TODO: Option to disable auto reloading
    // TODO: Option to enable write operations to function folder
    .action(actionRunner(runFunction));

module.exports = {
    run
}
