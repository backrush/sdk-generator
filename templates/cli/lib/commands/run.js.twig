const ignore = require("ignore");
const tar = require("tar");
const fs = require("fs");
const childProcess = require('child_process');
const chokidar = require('chokidar');
const inquirer = require("inquirer");
const path = require("path");
const { Command } = require("commander");
const { localConfig, globalConfig } = require("../config");
const { paginate } = require('../paginate');
const { questionsRunFunctions } = require("../questions");
const { actionRunner, success, log, error, commandDescriptions, drawTable } = require("../parser");
const { systemHasCommand, isPortTaken, getAllFiles } = require('../utils');
const { info } = require('console');

const activeDockerIds = {};

const openRuntimesVersion = 'v3';
const systemTools = {
    'node': {
        isCompiled: false,
        startCommand: "node src/server.js",
        commands: [
            { command: "node", docs: "https://nodejs.org/en/download/package-manager" },
            { command: "npm", docs: "https://nodejs.org/en/download/package-manager" },
        ],
        dependencyFiles: [ "package.json", "package-lock.json" ]
    },
    // TODO: Add all runtime needs
};

async function dockerStop(id) {
    delete activeDockerIds[id];    
    const stopProcess = childProcess.spawn('docker', ['rm', '--force', id], {
        stdio: 'pipe',
    });

    await new Promise((res) => { stopProcess.on('close', res) });
}

async function dockerPull(func) {
    return; // TODO: Remove
    log('Pulling Docker image of function runtime ...');

    const [ runtimeName, runtimeVersion ] = func.runtime.split('-', 2);
    const imageName = `openruntimes/${runtimeName}:${openRuntimesVersion}-${runtimeVersion}`;

    const pullProcess = childProcess.spawn('docker', ['pull', imageName], {
        stdio: 'pipe',
        pwd: path.join(process.cwd(), func.path)
    });

    pullProcess.stderr.on('data', (data) => {
        process.stderr.write(`\n${data}$ `);
    });

    await new Promise((res) => { pullProcess.on('close', res) });
}

async function dockerBuild(func) {
    log('Building function using Docker engine ...');

    const [ runtimeName, runtimeVersion ] = func.runtime.split('-', 2);
    const imageName = `openruntimes/${runtimeName}:${openRuntimesVersion}-${runtimeVersion}`;

    const functionDir = path.join(process.cwd(), func.path);

    const id = `${new Date().getTime().toString(16)}${Math.round(Math.random() * 1000000000).toString(16)}`;
    const params = ['run', '--rm', '--name', id, '-i', '-e', `OPEN_RUNTIMES_ENTRYPOINT=${func.entrypoint}`, '-v', `${functionDir}/:/mnt/code:rw`, imageName, 'sh', '-c', ` helpers/build.sh "${func.commands}"`];

    const buildProcess = childProcess.spawn('docker', params, {
        stdio: 'pipe',
        pwd: functionDir
    });

    buildProcess.stdout.on('data', (data) => {
        process.stdout.write(`\n${data}`);
    });
    
    buildProcess.stderr.on('data', (data) => {
        process.stderr.write(`\n${data}`);
    });

    activeDockerIds[id] = true;

    await new Promise((res) => { buildProcess.on('close', res) });

    delete activeDockerIds[id];
}

async function dockerStart(func, port) {
   log('Starting function using Docker engine ...');

   log("Permissions, events, CRON and timeouts dont apply when running locally.");

   log('ðŸ’¡ Hint: Function automatically restarts when you edit your code.');

   success(`Visit http://localhost:${port}/ to execute your function.`);
   
    const [ runtimeName, runtimeVersion ] = func.runtime.split('-', 2);
    const imageName = `openruntimes/${runtimeName}:${openRuntimesVersion}-${runtimeVersion}`;

    const tool = systemTools[runtimeName];

    const functionDir = path.join(process.cwd(), func.path);

    const id = `${new Date().getTime().toString(16)}${Math.round(Math.random() * 1000000000).toString(16)}`;
    const params = ['run', '--rm', '--name', id, '-i', '-e', 'OPEN_RUNTIMES_SECRET=', '-p', `${port}:3000`, '-v', `${functionDir}/.appwrite/logs:/mnt/logs:rw`, '-v', `${functionDir}/:/mnt/code:rw`, imageName, 'sh', '-c', ` helpers/start.sh "${tool.startCommand}"`];

    const execProcess = childProcess.spawn('docker', params, {
        stdio: 'pipe',
        pwd: functionDir
    });

    // TODO: Find a way to see context.log

    execProcess.stdout.on('data', (data) => {
        process.stdout.write(`\n${data}`);
    });
    
    execProcess.stderr.on('data', (data) => {
        process.stderr.write(`\n${data}`);
    });

    activeDockerIds[id] = true;
}

const runFunction = async ({ port, engine, functionId } = {}) => {
    // Selection
    if(!functionId) {
        const answers = await inquirer.prompt(questionsRunFunctions[0]);
        functionId = answers.function;
    }

    const functions = localConfig.getFunctions();
    const func = functions.find((f) => f.$id === functionId);
    if (!func) {
        throw new Error("Function '" + functionId + "' not found.")
    }

    const runtimeName = func.runtime.split('-')[0];
    const tool = systemTools[runtimeName];

    // Configuration: Port
    if(port) {
        port = +port;
    }

    if(isNaN(port)) {
        port = null;
    }

    if(port) {
        const taken = await isPortTaken(port);

        if(taken) {
            log(`Port ${port} is already used.`);
            port = null;
        }
    }

    if(!port) {
        const answers = await inquirer.prompt(questionsRunFunctions[1]);
        port = answers.port;
    }

    // Configuration: Engine
    if(engine !== "system" && engine !== "docker") {
        engine = null;
    }

    if(!engine) {
        const answers = await inquirer.prompt(questionsRunFunctions[2]);
        engine = answers.engine;
    }

    if(engine === 'docker') {
        log('ðŸ’¡ Hint: Using system is faster, but using Docker simulates the production environment precisely.');

        if(!systemHasCommand('docker')) {
            return error("Please install Docker first: https://docs.docker.com/engine/install/");
        }
    } else if(engine === 'system') {
        log('ðŸ’¡ Hint: Docker simulates the production environment precisely, but using system is faster');

        for(const command of tool.commands) {
            if(!systemHasCommand(command.command)) {
                return error(`Your system is missing command "${command.command}". Please install it first: ${command.docs}`);
            }
        }
    }

    // Settings
    const settings = {
        runtime: func.runtime,
        entrypoint: func.entrypoint,
        path: func.path,
        commands: func.commands,
    };
    log("Local function configuration:");
    drawTable([settings]);
    log('If you wish to change local settings, update appwrite.json file and rerun the command. To deploy the function, run: appwrite push function');

    process.on('SIGINT', () => {
        for(const id in activeDockerIds) {
            dockerStop(id);
        }

        process.exit();
    });

    if(engine === "docker") {
        await dockerPull(func);
        await dockerBuild(func);
        await dockerStart(func, port);

        let watcherRunning = false;

        childProcess.execSync(`sudo mkdir -p ${path.join(process.cwd(), func.path, '.appwrite/logs')}`, {
            pwd: path.join(process.cwd(), func.path)
        });
        chokidar.watch('.appwrite/logs', {
            cwd: path.join(process.cwd(), func.path),
            ignoreInitial: true,
        }).on('all', async (event, filePath) => {
            console.log(fs.readFileSync(path.join(process.cwd(), func.path, filePath)).toString());
        });

        chokidar.watch('.', {
            cwd: path.join(process.cwd(), func.path),
            ignoreInitial: true,
            ignored: [ ...(func.ignore ?? []), 'code.tar.gz', '.appwrite', '.appwrite/', '.appwrite/*', '.appwrite/**', '.appwrite/*.*', '.appwrite/**/*.*' ]
        }).on('all', async (event, filePath) => {
            if(watcherRunning) {
                info("File change detected but ignored, because live reload is already being ran.");
                return;
            }

            watcherRunning = true;

            log('Detected a change in ' + filePath);

            try {
                log('Stopping the function ...');

                for(const id in activeDockerIds) {
                    await dockerStop(id);
                }
    
                if(tool.isCompiled || tool.dependencyFiles.includes(filePath)) {
                    await dockerBuild(func);
                    await dockerStart(func, port);
                } else {
                    // TODO: Some try-catch approach, to rebuild if fails
                    log('Hot swapping function files ...');
                    
                    const functionPath = path.join(process.cwd(), func.path);
                    const hotSwapPath = path.join(functionPath, '.appwrite/hot-swap');
                    const buildPath = path.join(functionPath, 'code.tar.gz')

                    // TODO: Using Node code, no sudo
                    childProcess.execSync(`sudo mkdir -p ${hotSwapPath} && sudo chmod 777 ${buildPath} ${hotSwapPath} && sudo tar -zxf ${buildPath} -C ${hotSwapPath}`, {
                        pwd: path.join(process.cwd(), func.path)
                    });

                    const ignorer = ignore();
                    ignorer.add('.appwrite');

                    if (func.ignore) {
                        ignorer.add(func.ignore);
                    }

                    // TODO: Better approach
                    const filesToCopy = getAllFiles(functionPath).map((file) => path.relative(functionPath, file)).filter((file) => !ignorer.ignores(file));

                    const copyCommands = [];
                    for(const f of filesToCopy) {
                        const filePath = path.join(hotSwapPath, f);
                        copyCommands.push(`sudo rm -rf ${filePath}`);

                        const fileDir = path.dirname(filePath);
                        copyCommands.push(`sudo mkdir -p ${fileDir}`);

                        const sourcePath = path.join(functionPath, f);
                        copyCommands.push(`sudo cp ${sourcePath} ${filePath}`);
                    }
                    childProcess.execSync(copyCommands.join(" && "), {
                        pwd: path.join(process.cwd(), func.path)
                    });

                    console.log(path.join(process.cwd(), func.path, '.appwrite'));
                    /*
                    childProcess.execSync("sudo chmod -R 777 .", {
                        pwd: path.join(process.cwd(), func.path, '.appwrite')
                    });
                    */

                    childProcess.execSync(`sudo tar -C ${hotSwapPath} --exclude code.tar.gz -zcf ${buildPath} .`, {
                        pwd: hotSwapPath
                    });
                    
                    // TODO: Using Node code
                    childProcess.execSync(`sudo rm -rf ${hotSwapPath}`, {
                        pwd: path.join(process.cwd(), func.path)
                    });

                    await dockerStart(func, port);
                }
            } catch(err) {
                console.error(err);
            } finally {
                watcherRunning = false;
            }
        });
    }
}

const run = new Command("run")
    .alias("dev")
    .description(commandDescriptions['run'])
    .configureHelp({
        helpWidth: process.stdout.columns || 80
    })
    .action(actionRunner(async (_options, command) => {
        command.help();
    }));

run
    .command("function")
    .alias("functions")
    .description("Run functions in the current directory.")
    .option(`--functionId <functionId>`, `Function ID`)
    .option(`--port <port>`, `Local port`)
    .option(`--engine <engine>`, `Local engine, "system" or "docker"`)
    .action(actionRunner(runFunction));

module.exports = {
    run
}
