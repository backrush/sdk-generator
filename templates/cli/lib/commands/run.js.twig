const Tail = require('tail').Tail;
const EventEmitter = require('node:events');
const ignore = require("ignore");
const tar = require("tar");
const fs = require("fs");
const ID = require("../id");
const childProcess = require('child_process');
const chokidar = require('chokidar');
const inquirer = require("inquirer");
const path = require("path");
const { Command } = require("commander");
const { localConfig, globalConfig } = require("../config");
const { paginate } = require('../paginate');
const { functionsListVariables } = require('./functions');
const { usersGet, usersCreateJWT } = require('./users');
const { projectsCreateJWT } = require('./projects');
const { questionsRunFunctions } = require("../questions");
const { actionRunner, success, log, error, commandDescriptions, drawTable } = require("../parser");
const { systemHasCommand, isPortTaken, getAllFiles } = require('../utils');

const activeDockerIds = {};

const openRuntimesVersion = 'v3';
const runtimeNames = {
    'node': 'Node.js',
    'php': 'PHP',
    'ruby': 'Ruby',
    'python': 'Python',
    'python-ml': 'Python (ML)',
    'deno': 'Deno',
    'dart': 'Dart',
    'dotnet': '.NET',
    'java': 'Java',
    'swift': 'Swift',
    'kotlin': 'Kotlin',
    'bun': 'Bun'
};
const systemTools = {
    'node': {
        isCompiled: false,
        startCommand: "node src/server.js",
        dependencyFiles: [ "package.json", "package-lock.json" ]
    },
    'php': {
        isCompiled: false,
        startCommand: "php src/server.php",
        dependencyFiles: [ "composer.json", "composer.lock" ]
    },
    'ruby': {
        isCompiled: false,
        startCommand: "bundle exec puma -b tcp://0.0.0.0:3000 -e production",
        dependencyFiles: [ "Gemfile", "Gemfile.lock" ]
    },
    'python': {
        isCompiled: false,
        startCommand: "python3 src/server.py",
        dependencyFiles: [ "requirements.txt", "requirements.lock" ]
    },
    'python-ml': {
        isCompiled: false,
        startCommand: "python3 src/server.py",
        dependencyFiles: [ "requirements.txt", "requirements.lock" ]
    },
    'deno': {
        isCompiled: false,
        startCommand: "deno start",
        dependencyFiles: [ ]
    },
    'dart': {
        isCompiled: true,
        startCommand: "src/function/server",
        dependencyFiles: [ ]
    },
    'dotnet': {
        isCompiled: true,
        startCommand: "dotnet src/function/DotNetRuntime.dll",
        dependencyFiles: [ ]
    },
    'java': {
        isCompiled: true,
        startCommand: "java -jar src/function/java-runtime-1.0.0.jar",
        dependencyFiles: [ ]
    },
    'swift': {
        isCompiled: true,
        startCommand: "src/function/Runtime serve --env production --hostname 0.0.0.0 --port 3000",
        dependencyFiles: [ ]
    },
    'kotlin': {
        isCompiled: true,
        startCommand: "java -jar src/function/kotlin-runtime-1.0.0.jar",
        dependencyFiles: [ ]
    },
    'bun': {
        isCompiled: false,
        startCommand: "bun src/server.ts",
        dependencyFiles: [ "package.json", "package-lock.json", "bun.lockb" ]
    },
};

const JwtManager = {
    userJwt: null,
    functionJwt: null,

    timerWarn: null,
    timerError: null,

    async setup(userId = null) {
        if(this.timerWarn) {
            clearTimeout(this.timerWarn);
        }

        if(this.timerError) {
            clearTimeout(this.timerError);
        }

        this.timerWarn = setTimeout(() => {
            log("Warning: Authorized JWT will expire in 5 minutes. Please stop and re-run the command to refresh tokens for 1 hour.");
        }, 1000 * 60 * 55); // 55 mins

        this.timerError = setTimeout(() => {
            log("Warning: Authorized JWT just expired. Please stop and re-run the command to obtain new tokens with 1 hour validity.");
            log("Some Appwrite API communication is not authorized now.")
        }, 1000 * 60 * 60); // 60 mins

        if(userId) {
            await usersGet({
                userId,
                parseOutput: false
            });
            const userResponse = await usersCreateJWT({
                userId,
                duration: 60*60,
                parseOutput: false
            });
            this.userJwt = userResponse.jwt;
        }
        
        const functionResponse = await projectsCreateJWT({
            projectId: localConfig.getProject().projectId,
            // TODO: Once we have endpoint for this, use it
            scopes: ["sessions.write","users.read","users.write","teams.read","teams.write","databases.read","databases.write","collections.read","collections.write","attributes.read","attributes.write","indexes.read","indexes.write","documents.read","documents.write","files.read","files.write","buckets.read","buckets.write","functions.read","functions.write","execution.read","execution.write","locale.read","avatars.read","health.read","providers.read","providers.write","messages.read","messages.write","topics.read","topics.write","subscribers.read","subscribers.write","targets.read","targets.write","rules.read","rules.write","migrations.read","migrations.write","vcs.read","vcs.write","assistant.read"],
            duration: 60*60,
            parseOutput: false
        });
        this.functionJwt = functionResponse.jwt;
    }
};

const Queue = {
    files: [],
    locked: false,
    events: new EventEmitter(),
    debounce: null,
    push(file) {
        if(!this.files.includes(file)) {
            this.files.push(file);
        }

        if(!this.locked) {
            this._trigger();
        }
    },
    lock() {
        this.files = [];
        this.locked = true;
    },
    unlock() {
        this.locked = false;
        if(this.files.length > 0) {
            this._trigger();
        }
    },
    _trigger() {
        if(this.debounce) {
            return;
        }

        this.debounce = setTimeout(() => {
            this.events.emit('reload', { files: this.files });
            this.debounce = null;
        }, 300);
    }
};

async function dockerStop(id) {
    delete activeDockerIds[id];
    const stopProcess = childProcess.spawn('docker', ['rm', '--force', id], {
        stdio: 'pipe',
    });

    await new Promise((res) => { stopProcess.on('close', res) });
}

async function dockerPull(func) {
    log('Pulling Docker image of function runtime ...');

    const runtimeChunks = func.runtime.split("-");
    const runtimeVersion = runtimeChunks.pop();
    const runtimeName = runtimeChunks.join("-");
    const imageName = `openruntimes/${runtimeName}:${openRuntimesVersion}-${runtimeVersion}`;

    const pullProcess = childProcess.spawn('docker', ['pull', imageName], {
        stdio: 'pipe',
        pwd: path.join(process.cwd(), func.path)
    });

    pullProcess.stderr.on('data', (data) => {
        process.stderr.write(`\n${data}$ `);
    });

    await new Promise((res) => { pullProcess.on('close', res) });
}

async function dockerBuild(func, variables) {
    log('Building function using Docker ...');

    const runtimeChunks = func.runtime.split("-");
    const runtimeVersion = runtimeChunks.pop();
    const runtimeName = runtimeChunks.join("-");
    const imageName = `openruntimes/${runtimeName}:${openRuntimesVersion}-${runtimeVersion}`;

    const functionDir = path.join(process.cwd(), func.path);

    const id = ID.unique();

    const params = [ 'run' ];
    params.push('--name', id);
    params.push('-v', `${functionDir}/:/mnt/code:rw`);
    params.push('-e', 'APPWRITE_ENV=development');
    params.push('-e', 'OPEN_RUNTIMES_ENV=development');
    params.push('-e', 'OPEN_RUNTIMES_SECRET=');
    params.push('-e', `OPEN_RUNTIMES_ENTRYPOINT=${func.entrypoint}`);

    for(const k of Object.keys(variables)) {
        params.push('-e', `${k}=${variables[k]}`);
    }

    params.push(imageName, 'sh', '-c', `helpers/build.sh "${func.commands}"`);

    const buildProcess = childProcess.spawn('docker', params, {
        stdio: 'pipe',
        pwd: functionDir
    });

    buildProcess.stdout.on('data', (data) => {
        process.stdout.write(`\n${data}`);
    });
    
    buildProcess.stderr.on('data', (data) => {
        process.stderr.write(`\n${data}`);
    });

    await new Promise((res) => { buildProcess.on('close', res) });

    const copyPath = path.join(process.cwd(), func.path, '.appwrite', 'build.tar.gz');
    const copyDir = path.dirname(copyPath);
    if (!fs.existsSync(copyDir)) {
        fs.mkdirSync(copyDir, { recursive: true });
    }

    const copyProcess = childProcess.spawn('docker', ['cp', `${id}:/mnt/code/code.tar.gz`, copyPath], {
        stdio: 'pipe',
        pwd: functionDir
    });

    await new Promise((res) => { copyProcess.on('close', res) });

    const cleanupProcess = childProcess.spawn('docker', ['rm', '--force', id], {
        stdio: 'pipe',
        pwd: functionDir
    });

    await new Promise((res) => { cleanupProcess.on('close', res) });

    delete activeDockerIds[id];

    const tempPath = path.join(process.cwd(), func.path, 'code.tar.gz');
    if (fs.existsSync(tempPath)) {
        fs.rmSync(tempPath, { force: true });
    } 
}

async function dockerStart(func, variables, port) {
   log('Starting function using Docker ...');

   log("Permissions, events, CRON and timeouts dont apply when running locally.");

   log('ðŸ’¡ Hint: Function automatically restarts when you edit your code.');

   success(`Visit http://localhost:${port}/ to execute your function.`);
   
   
   const runtimeChunks = func.runtime.split("-");
   const runtimeVersion = runtimeChunks.pop();
   const runtimeName = runtimeChunks.join("-");
    const imageName = `openruntimes/${runtimeName}:${openRuntimesVersion}-${runtimeVersion}`;

    const tool = systemTools[runtimeName];

    const functionDir = path.join(process.cwd(), func.path);

    const id = ID.unique();

    const params = [ 'run' ];
    params.push('--rm');
    params.push('-d');
    params.push('--name', id);
    params.push('-p', `${port}:3000`);
    params.push('-e', 'APPWRITE_ENV=development');
    params.push('-e', 'OPEN_RUNTIMES_ENV=development');
    params.push('-e', 'OPEN_RUNTIMES_SECRET=');

   for(const k of Object.keys(variables)) {
        params.push('-e', `${k}=${variables[k]}`);
    }

    params.push('-v', `${functionDir}/.appwrite/logs.txt:/mnt/logs/dev_logs.log:rw`);
    params.push('-v', `${functionDir}/.appwrite/errors.txt:/mnt/logs/dev_errors.log:rw`);
    params.push('-v', `${functionDir}/.appwrite/build.tar.gz:/mnt/code/code.tar.gz:ro`);
    params.push(imageName, 'sh', '-c', `helpers/start.sh "${tool.startCommand}"`);
    
    childProcess.spawn('docker', params, {
        stdio: 'pipe',
        pwd: functionDir
    });

    activeDockerIds[id] = true;
}

async function dockerCleanup() {
    const ids = Object.keys(activeDockerIds);
    for await (const id of ids) {
        await dockerStop(id);
    }

    const functions = localConfig.getFunctions();
    for(const func of functions) {
        const appwritePath = path.join(process.cwd(), func.path, '.appwrite');
        if (fs.existsSync(appwritePath)) {
            fs.rmSync(appwritePath, { recursive: true, force: true });
        }

        const tempPath = path.join(process.cwd(), func.path, 'code.tar.gz');
        if (fs.existsSync(tempPath)) {
            fs.rmSync(tempPath, { force: true });
        }
    }
}

const runFunction = async ({ port, functionId, noVariables, noReload, userId } = {}) => {
    // Selection
    if(!functionId) {
        const answers = await inquirer.prompt(questionsRunFunctions[0]);
        functionId = answers.function;
    }

    const functions = localConfig.getFunctions();
    const func = functions.find((f) => f.$id === functionId);
    if (!func) {
        throw new Error("Function '" + functionId + "' not found.")
    }

    const runtimeName = func.runtime.split("-").slice(0, -1).join("-");
    const tool = systemTools[runtimeName];

    // Configuration: Port
    if(port) {
        port = +port;
    }

    if(isNaN(port)) {
        port = null;
    }

    if(port) {
        const taken = await isPortTaken(port);

        if(taken) {
            log(`Port ${port} is already used.`);
            port = null;
        }
    }

    if(!port) {
        const answers = await inquirer.prompt(questionsRunFunctions[1]);
        port = answers.port;
    }

    // Configuration: Engine
    if(!systemHasCommand('docker')) {
        return error("Please install Docker first: https://docs.docker.com/engine/install/");
    }

    // Settings
    const settings = {
        runtime: func.runtime,
        entrypoint: func.entrypoint,
        path: func.path,
        commands: func.commands,
    };

    log("Local function configuration:");
    drawTable([settings]);
    log('If you wish to change local settings, update appwrite.json file and rerun the command. To deploy the function, run: appwrite push function');

    await dockerCleanup();

    process.on('SIGINT', async () => {
        log('Cleaning up ...');
        await dockerCleanup();
        success();
        process.exit();
    });

    const logsPath = path.join(process.cwd(), func.path, '.appwrite/logs.txt');
    const errorsPath = path.join(process.cwd(), func.path, '.appwrite/errors.txt');

    if(!fs.existsSync(path.dirname(logsPath))) {
        fs.mkdirSync(path.dirname(logsPath), { recursive: true });
    }

    if (!fs.existsSync(logsPath)) {
        fs.writeFileSync(logsPath, '');
    }

    if (!fs.existsSync(errorsPath)) {
        fs.writeFileSync(errorsPath, '');
    }

    const variables = {};
    if(!noVariables) {
        if (globalConfig.getEndpoint() === '' || globalConfig.getCookie() === '') {
            error("No user is signed in. To sign in, run: appwrite login. Function will run locally, but will not have your function's environment variables set.");
        } else {
            try {
                const { variables: remoteVariables } = await paginate(functionsListVariables, {
                    functionId: func['$id'],
                    parseOutput: false
                }, 100, 'variables');

                remoteVariables.forEach((v) => {
                    variables[v.key] = v.value;
                });
            } catch(err) {
                error("Could not fetch remote variables: " + err.message);
                error("Function will run locally, but will not have your function's environment variables set.");
            }
        }
    }

    variables['APPWRITE_FUNCTION_API_ENDPOINT'] = globalConfig.getFrom('endpoint');
    variables['APPWRITE_FUNCTION_ID'] = func.$id;
    variables['APPWRITE_FUNCTION_NAME'] = func.name;
    variables['APPWRITE_FUNCTION_DEPLOYMENT'] = ''; // TODO: Implement when relevant
    variables['APPWRITE_FUNCTION_PROJECT_ID'] = localConfig.getProject().projectId;
    variables['APPWRITE_FUNCTION_RUNTIME_NAME'] = runtimeNames[runtimeName] ?? '';
    variables['APPWRITE_FUNCTION_RUNTIME_VERSION'] = func.runtime;

    await JwtManager.setup(userId);

    const headers = {};
    headers['x-appwrite-key'] = JwtManager.functionJwt ?? '';
    headers['x-appwrite-trigger'] = 'http';
    headers['x-appwrite-event'] = '';
    headers['x-appwrite-user-id'] = userId ?? '';
    headers['x-appwrite-user-jwt'] = JwtManager.userJwt ?? '';
    variables['OPEN_RUNTIMES_HEADERS'] = JSON.stringify(headers);

    await dockerPull(func);
    await dockerBuild(func, variables);
    await dockerStart(func, variables, port);

    new Tail(logsPath).on("line", function(data) {
        console.log(data);
    });
    new Tail(errorsPath).on("line", function(data) {
        console.log(data);
    });

    if(!noReload) {
        chokidar.watch('.', {
            cwd: path.join(process.cwd(), func.path),
            ignoreInitial: true,
            ignored: [ ...(func.ignore ?? []), 'code.tar.gz', '.appwrite', '.appwrite/', '.appwrite/*', '.appwrite/**', '.appwrite/*.*', '.appwrite/**/*.*' ]
        }).on('all', async (_event, filePath) => {
            Queue.push(filePath);
        });
    }

    Queue.events.on('reload', async ({ files }) => {
        Queue.lock();

        log('Live-reloading due to file changes: ');
        for(const file of files) {
            log(`- ${file}`);
        }

        try {
            log('Stopping the function ...');

            for(const id in activeDockerIds) {
                await dockerStop(id);
            }

            const dependencyFile = files.find((filePath) => tool.dependencyFiles.includes(filePath));
            if(tool.isCompiled || dependencyFile) {
                log(`Rebuilding the function due to cange in ${dependencyFile} ...`);
                await dockerBuild(func, variables);
                await dockerStart(func, variables, port);
            } else {
                log('Hot-swapping function files ...');
                
                const functionPath = path.join(process.cwd(), func.path);
                const hotSwapPath = path.join(functionPath, '.appwrite/hot-swap');
                const buildPath = path.join(functionPath, '.appwrite/build.tar.gz');

                // Prepare temp folder
                if (!fs.existsSync(hotSwapPath)) {
                    fs.mkdirSync(hotSwapPath, { recursive: true });
                } else {
                    fs.rmSync(hotSwapPath, { recursive: true, force: true });
                    fs.mkdirSync(hotSwapPath, { recursive: true });
                }

                await tar
                    .extract({
                        gzip: true,
                        sync: true,
                        cwd: hotSwapPath,
                        file: buildPath
                    });

                const ignorer = ignore();
                ignorer.add('.appwrite');
                if (func.ignore) {
                    ignorer.add(func.ignore);
                }

                const filesToCopy = getAllFiles(functionPath).map((file) => path.relative(functionPath, file)).filter((file) => !ignorer.ignores(file));
                for(const f of filesToCopy) {
                    const filePath = path.join(hotSwapPath, f);
                    if (fs.existsSync(filePath)) {
                        fs.rmSync(filePath, { force: true });
                    } 

                    const fileDir = path.dirname(filePath);
                    if (!fs.existsSync(fileDir)) {
                        fs.mkdirSync(fileDir, { recursive: true });
                    }

                    const sourcePath = path.join(functionPath, f);
                    fs.copyFileSync(sourcePath, filePath);
                }

                await tar
                    .create({
                        gzip: true,
                        sync: true,
                        cwd: hotSwapPath,
                        file: buildPath
                    }, ['.']);
                
                fs.rmSync(hotSwapPath, { recursive: true, force: true });

                await dockerStart(func, variables, port);
            }
        } catch(err) {
            console.error(err);
        } finally {
            Queue.unlock();
        }
    });
}

const run = new Command("run")
    .alias("dev")
    .description(commandDescriptions['run'])
    .configureHelp({
        helpWidth: process.stdout.columns || 80
    })
    .action(actionRunner(async (_options, command) => {
        command.help();
    }));

run
    .command("function")
    .alias("functions")
    .description("Run functions in the current directory.")
    .option(`--functionId <functionId>`, `Function ID`)
    .option(`--port <port>`, `Local port`)
    .option(`--userId <userId>`, `ID of user to impersonate`)
    .option(`--noVariables`, `Prevent pulling variables from function settings`)
    .option(`--noReload`, `Prevent live reloading of server when changes are made to function files`)
    .action(actionRunner(runFunction));

module.exports = {
    run
}
