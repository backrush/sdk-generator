import 'dart:async';
import 'dart:convert';
import 'package:web_socket_channel/web_socket_channel.dart';
import 'package:web_socket_channel/status.dart';
import 'exception.dart';
import 'realtime_subscription.dart';
import 'client.dart';

typedef Future<WebSocketChannel> WebSocketChannelFactory(Uri uri);

mixin RealtimeMixin {
  late Client client;
  Map<String, List<StreamController>> _channels = {};
  WebSocketChannel? _websok;
  String? _lastUrl;
  late WebSocketChannelFactory getWebSocketChannel;
  Map<String, dynamic>? _lastMessage;

  _closeConnection() {
    _websok?.sink.close(normalClosure);
  }

  _createSocket() async {
    final uri = _prepareUri();
    if (_websok == null) {
      await getWebSocketChannel(uri);
    }
    if (_lastUrl == uri.toString() && _websok?.closeCode == null) {
      return;
    }
    _closeConnection();
    _lastUrl = uri.toString();
    print('subscription: $_lastUrl');
    _websok = await getWebSocketChannel(uri);

    try {
      _websok?.stream.listen((event) {
        final data = jsonDecode(event);
        _lastMessage = data;
        handleError(data);
        if (data['channels'] != null) {
          List<String> received = List<String>.from(data['channels']);
          received.forEach((channel) {
            if (this._channels[channel] != null) {
              this._channels[channel]!.forEach((stream) {
                stream.sink.add(event);
              });
            }
          });
        }
      });
    } catch (e) {
      if (e is {{spec.title | caseUcfirst}}Exception) {
        rethrow;
      }
      if (e is WebSocketChannelException) {
        throw {{spec.title | caseUcfirst}}Exception(e.message);
      }
      throw {{spec.title | caseUcfirst}}Exception(e.toString());
    }
  }

  Uri _prepareUri() {
    if (client.endPointRealtime == null) {
      throw {{spec.title | caseUcfirst}}Exception(
          "Please set endPointRealtime to connect to realtime server");
    }
    var uri = Uri.parse(client.endPointRealtime!);
    return Uri(
      host: uri.host,
      scheme: uri.scheme,
      port: uri.port,
      queryParameters: {
        "project": client.config['project'],
        "channels[]": _channels.keys.toList(),
      },
      path: uri.path + "/realtime",
    );
  }

  RealtimeSubscription subscribeTo(List<String> channels) {
    StreamController controller = StreamController.broadcast();
    channels.forEach((channel) {
      if (!this._channels.containsKey(channel)) {
        this._channels[channel] = [];
      }
      this._channels[channel]!.add(controller);
    });
    Future.delayed(Duration.zero, () => _createSocket());
    RealtimeSubscription subscription = RealtimeSubscription(
        stream: controller.stream,
        close: () {
          controller.close();
          channels.forEach((channel) {
            this._channels[channel]!.remove(controller);
            if (this._channels[channel]!.length < 1) {
              this._channels.remove(channel);
            }
          });
          Future.delayed(Duration.zero, () => _createSocket());
        });
    return subscription;
  }

  void handleError(Map<String, dynamic> data) {
    if (data.containsKey('code')) {
      if (data['code'] == 1008) {
        throw {{spec.title | caseUcfirst}}Exception(data["message"], data["code"]);
      } else {
        print("Reconnecting in one second.");
        Future.delayed(Duration(seconds: 1), () {
          _createSocket();
        });
      }
    }
  }
}
